const data = [
    {
        "id": "5bd4772a14e994202cd5bdb7",
        "author_id": "504c28a2e2b845157708cb61",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>",
        "title": "服务器迁移至 aws 日本机房",
        "last_reply_at": "2018-11-19T05:34:10.730Z",
        "good": false,
        "top": true,
        "reply_count": 79,
        "visit_count": 5302,
        "create_at": "2018-10-27T14:33:14.694Z",
        "author": {
            "loginname": "alsotang",
            "avatar_url": "https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"
        }
    },
    {
        "id": "5beb95fbbe1b120abac59180",
        "author_id": "4efc278525fa69ac69000013",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FpnxBr4tLD07ssQwSr6QjyoPeiyN\" alt=\"图片 1.png\">\n阿里云MVP携手cnodejs，寻找下一个MVP！专属服务、大咖交流、企业游学等你来！申请就送100元代金券！</p>\n<p>“传递技术力量，传承布道精神。”阿里云MVP（最有价值专家）第七期全球招募开启，与cnodejs携手，寻找热爱技术、乐于分享、关注个人成长的你！</p>\n<p>戳链接，通过【cnodejs绿色通道】一键直达：\n<a href=\"https://mvp.aliyun.com/mvp/apply?recommendType=2&amp;recommendId=LjJNaiBNwbNGUe8RWFb9+A==\">https://mvp.aliyun.com/mvp/apply?recommendType=2&amp;recommendId=LjJNaiBNwbNGUe8RWFb9+A==</a></p>\n<p><strong>前20名申请即提供100元代金券，认证成功还送阿里云T-shirt。</strong>\n<img src=\"//static.cnodejs.org/FjINSUXjVJ0hBXtRW7vsxnO0Qcjp\" alt=\"图片 2.png\">\n如果你是资深开发者，想第一时间接触最新云技术，实现个人能力跃升；</p>\n<p>如果你是深度的云产品使用者，想携手阿里云推动产品体验升级；</p>\n<p>如果你是创业者，想结识同业同行，把握数字化转型的机遇；</p>\n<p>如果你是各行业转型实践者，想与业内大咖交流论道，提升技术影响力……</p>\n<p>那么，你一定不能错过这次阿里云MVP招募！加入阿里云MVP，实现你的技术梦想。</p>\n<h2>阿里云MVP 是谁？</h2>\n<p>阿里云最有价值专家，简称 MVP(Most Valuable Professional)，是各行业数字化转型的技术实践者。正如阿里云总裁胡晓明所说，<strong>“阿里云MVP是中国互联网的力量，是中国技术变革、经济变革的力量。</strong>”</p>\n<p><img src=\"//static.cnodejs.org/FkZ-x1vY4SAtuKTvGzvmTchWXtVb\" alt=\"图片 3.png\">\n<img src=\"//static.cnodejs.org/FqJWiqeC_59ltQo3jgqjUWDFKwK-\" alt=\"图片 4.png\"></p>\n<p>他们中，有擅长写代码、做架构的优秀开发者；</p>\n<p>有登上云栖大会等舞台，善于总结和分享的技术布道者；</p>\n<p>有创业的技术合伙人、CEO；</p>\n<p>有帮助更多客户使用阿里云产品的生态合作伙伴；</p>\n<p>有在新零售、物联网、房地产、金融、游戏、医疗等领域推动数字转型的技术带头人……</p>\n<p>加入阿里云MVP，你将成为他们中的一员。</p>\n<h2>阿里云MVP有哪些权益？</h2>\n<p>只要成为MVP，即可享受定制礼包、专享服务、高端闭门会议、创客大赛提名、阿里云官方活动主推等丰厚权益。</p>\n<p>升级后，还可以获得免费云栖大会城市峰会门票、登上云栖大会的演讲台、参加全球技术留学，与顶级技术专家交流学习等等。\n<img src=\"//static.cnodejs.org/Fkvr-cLXf4b-jCAqglkTylJzHwwX\" alt=\"图片 5.png\"></p>\n<h2>如何加入阿里云MVP？</h2>\n<p>点击【cnodejs绿色通道】，立即申请</p>\n<p><a href=\"https://mvp.aliyun.com/mvp/apply?recommendType=2&amp;recommendId=LjJNaiBNwbNGUe8RWFb9+A==\">https://mvp.aliyun.com/mvp/apply?recommendType=2&amp;recommendId=LjJNaiBNwbNGUe8RWFb9+A==</a></p>\n<p>成为阿里云MVP，成为更好的自己！\n<img src=\"//static.cnodejs.org/Flta1WwbcKWswj2V8mgowB7R4rIF\" alt=\"图片 6.png\"></p>\n<h2>了解更多：</h2>\n<h3>阿里云MVP有多少人？</h3>\n<p>2017 年 6 月，阿里云总裁胡晓明在上海云栖大会上发布了阿里云MVP计划。截至目前，全球已有20多个国家和地区，300多位云计算专家成为阿里云MVP。他们覆盖人工智能、大数据、运维、区块链、系统架构、解决方案、安全等十几个技术领域，涉及物联网、金融、新零售、工业制造业、基因、安全、房地产等近二十个行业。可以说，几乎每个行业数据转型的最前线，都有阿里云MVP的身影。</p>\n<h3>加入MVP后，可以参加哪些活动？</h3>\n<p><img src=\"//static.cnodejs.org/FvDDqw9fuD5_E3Tv_KynRoYHKJi0\" alt=\"图片 7.png\">\n百位云计算专家齐聚湖畔大学，阿里云MVP全球闭门会聚焦数字化转型\n<img src=\"//static.cnodejs.org/Ft776gyGpWrxgCREa-oZAjh5kuFJ\" alt=\"图片 8.png\">\n阿里云MVP登上云栖大会舞台，进行技术布道\n<img src=\"//static.cnodejs.org/FvjDYsP9BYlq3QLtDfReikOoipep\" alt=\"图片 9.png\">\n阿里云MVP“抢拍”公益项目，以技术温暖世界</p>\n<h3>MVP代表阿里云吗？</h3>\n<p>不代表。MVP不是阿里巴巴的员工，他们也不代表阿里云发言。MVP仅是因其在技术的杰出成就，而获得阿里云认证的第三方个人。</p>\n<h3>多久评选一次 MVP？</h3>\n<p>您可以随时在 MVP 平台提交申请，我们将定期进行审核。在审核过程中，将与您取得联系以获取更多信息。</p>\n<p>每个季度评选一次，并会在每个季度末宣布 MVP 入围情况。如果遗憾落选，可在公布名单后，重新到 MVP 平台提交申请。</p>\n</div>",
        "title": "阿里云MVP携手cnodejs，寻找下一个MVP！专属服务、大咖交流、企业游学等你来！申请就送100元代金券！",
        "last_reply_at": "2018-11-18T13:20:11.182Z",
        "good": false,
        "top": true,
        "reply_count": 9,
        "visit_count": 907,
        "create_at": "2018-11-14T03:26:51.458Z",
        "author": {
            "loginname": "JacksonTian",
            "avatar_url": "https://avatars3.githubusercontent.com/u/327019?v=4&s=120"
        }
    },
    {
        "id": "5baee8de9545eaf107b9c6f3",
        "author_id": "51f0f267f4963ade0e08f503",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h1>Node.js 新生态</h1>\n<p>关于 SSR、IoT、应用治理，以及来自腾讯的新物种 —— Tars.js，</p>\n<p>腾讯、ThoughtWorks、阿里巴巴的 4 位分享者，期待和你交流碰撞层出不穷的 Node.js 新应用场景。</p>\n<h2>Agenda</h2>\n<p><img src=\"//static.cnodejs.org/FmVpEKuYsrXt8ek9z8d6DjFexMAc\" alt=\"20180929110352.png\"></p>\n<p>时间：2018.10.13\n地点：深圳后海阿里中心\n报名链接: <a href=\"https://survey.alibaba.com/survey/AgD9rVfQT\">https://survey.alibaba.com/survey/AgD9rVfQT</a>\n活动主页: <a href=\"http://nodejs.club/\">http://nodejs.club/</a></p>\n<p>注意: 沙龙场地有限，在报名链接中仔细填写「关注Node.js 新生态中的哪些具体问题」对最终挑选参加资格会有帮助。</p>\n</div>",
        "title": "Node 地下铁第七期「深圳站」线下沙龙邀约 - Node.js 新生态",
        "last_reply_at": "2018-11-13T09:56:20.769Z",
        "good": false,
        "top": true,
        "reply_count": 28,
        "visit_count": 5599,
        "create_at": "2018-09-29T02:52:14.701Z",
        "author": {
            "loginname": "lellansin",
            "avatar_url": "https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"
        }
    },
    {
        "id": "5befe1b1be1b120abac5a592",
        "author_id": "5b5a7729b71aedfe4c12652b",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>6套经典node.js+vue项目实战视频教程，大家看看下面具体教程，有需要的可以学习一下哦</p>\n<p><img src=\"//static.cnodejs.org/FisDxxcRtOtl7qWtIwYMfYzDTr2G\" alt=\"11111.jpg\"></p>\n<p><strong>教程如下：</strong>\n[node]7天搞定NodeJS微信公众号开发\n[vue]vue2.0+node.js+MongoDB全栈打造商城（新录制）\nVue+Node+MongoDB小程序公众号全栈项目开发实战\nnode.js从入门到实战教育项目\nVue+Node+MongoDB小程序公众号全栈项目开发实战\n【实战】Node.js + Web Socket 打造即时通讯聊天程序</p>\n<p>下载地址：<a href=\"http://www.sucaihuo.com/video/378.html\">http://www.sucaihuo.com/video/378.html</a></p>\n</div>",
        "title": "6套经典node.js+vue项目实战视频教程",
        "last_reply_at": "2018-11-19T07:12:26.644Z",
        "good": false,
        "top": false,
        "reply_count": 3,
        "visit_count": 295,
        "create_at": "2018-11-17T09:38:57.164Z",
        "author": {
            "loginname": "codeofking",
            "avatar_url": "https://avatars2.githubusercontent.com/u/41748064?v=4&s=120"
        }
    },
    {
        "id": "5bed6c77a05b0e0ae443b9ff",
        "author_id": "52273230552118f11a192977",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>vue项目部署  <a href=\"http://www.a.com\">www.a.com</a> 是一个vue项目\n<a href=\"http://www.a.com/news\">www.a.com/news</a> 是一个vue项目</p>\n<p>nginx怎么配呢？ 用路由的 history模式</p>\n<p>现在 <a href=\"http://www.a.com/news/show/1111\">www.a.com/news/show/1111</a>  正常是没问题的</p>\n<p>一刷新就不行了  被 <a href=\"http://www.a.com\">www.a.com</a> 劫持走了 有办法么？</p>\n</div>",
        "title": "请教下 vue的项目部署问题",
        "last_reply_at": "2018-11-19T06:24:53.685Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 317,
        "create_at": "2018-11-15T12:54:15.804Z",
        "author": {
            "loginname": "cobola",
            "avatar_url": "https://avatars1.githubusercontent.com/u/4435875?v=4&s=120"
        }
    },
    {
        "id": "5bf256c7e6481c5709f5d23c",
        "author_id": "5368d36b3a72ebbe0a00cec3",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>Client does not support authentication protocol requested by server; consider upgrading MySQL client\n<img src=\"//static.cnodejs.org/FuHpjIwWoO5WgPQyUUr7OWfXQedO\" alt=\"1542608545(1).png\">\n<img src=\"//static.cnodejs.org/FndADZrgMqo2vGkPTUnXBWrSS7Vq\" alt=\"1542608422(1).png\">\n<img src=\"//static.cnodejs.org/FqvXn0y1-Iy6JIQ27-l5I0MAR_gk\" alt=\"1542608442(1).png\"></p>\n</div>",
        "title": "请教egg-mysql 报错 急",
        "last_reply_at": "2018-11-19T06:23:03.419Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 38,
        "create_at": "2018-11-19T06:23:03.419Z",
        "author": {
            "loginname": "JackWon",
            "avatar_url": "https://avatars1.githubusercontent.com/u/7123677?v=4&s=120"
        }
    },
    {
        "id": "5bf25659be1b120abac5ac7a",
        "author_id": "5bf25005e6481c5709f5d1be",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>在用oracledb模块与oracle数据库建立了连接池的情况下，oracle数据库关闭并重启了，原有连接池如何与数据建立重新连接？</p>\n</div>",
        "title": "请教一下，oracledb模块连接oracle数据库的重连问题",
        "last_reply_at": "2018-11-19T06:21:13.107Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 34,
        "create_at": "2018-11-19T06:21:13.107Z",
        "author": {
            "loginname": "maozemin",
            "avatar_url": "https://avatars2.githubusercontent.com/u/27715426?v=4&s=120"
        }
    },
    {
        "id": "5bf23e61e6481c5709f5d15e",
        "author_id": "5a7a5d505321b5396004ec1e",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h1>nt-addon-wechatapi</h1>\n<p>基于 nest 封装的 微信公众平台 API</p>\n<h2>贡献说明</h2>\n<p>我们欢迎 Nest.js 使用者来参与这个插件的开发，作为一个贡献者，请您遵循以下原则：</p>\n<ul>\n<li>代码提交规范，参考 <a href=\"https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#\">Git Commit Message Conventions</a></li>\n<li>始终从 develop checkout 一个新分支，命名规范为 feature/xxx，xxx 必须具有可读性，如：微信-普通商户版-扫码支付 =&gt; feature/wechat-native-pay</li>\n<li>在 checkout 新分支前，先在本地 develop 分支拉取远程 develop 分支的最新代码</li>\n<li>文件命名规则请参考项目目前的命名规则，如：微信支付中，order.interface.ts 代表所有订单相关的请求参数和返回结果的定义，swipe.pay.service.ts 代表付款码支付的业务逻辑</li>\n</ul>\n<h2>功能开发</h2>\n<p>请先查阅 Roadmap，确保你想贡献的功能没有正在被实现。然后在 <strong>issue</strong> 里提交一个贡献请求，注明想要贡献的功能。</p>\n<h2>发现 Bug ？</h2>\n<p>如果你在源码中发现bug，请你先在本仓库的 <strong>issue</strong> 提交一个bug问题。在你提交完bug问题后，我们很乐意接受你提交一个 <strong>PR</strong> 来帮助我们修复这个bug。</p>\n<h2>QQ 群</h2>\n<p>322247106</p>\n<h2>Roadmap</h2>\n<ul>\n<li>[ ] 发送客服消息（文本、图片、语音、视频、音乐、图文）</li>\n<li>[ ] 菜单操作（查询、创建、删除、个性化菜单）</li>\n<li>[ ] 二维码（创建临时、永久二维码，查看二维码URL）</li>\n<li>[ ] 分组操作（查询、创建、修改、移动用户到分组）</li>\n<li>[ ] 用户信息（查询用户基本信息、获取关注者列表）</li>\n<li>[ ] 媒体文件（上传、获取）</li>\n<li>[ ] 群发消息（文本、图片、语音、视频、图文）</li>\n<li>[ ] 客服记录（查询客服记录，查看客服、查看在线客服）</li>\n<li>[ ] 群发消息</li>\n<li>[ ] 公众号支付（发货通知、订单查询）</li>\n<li>[ ] 微信小店（商品管理、库存管理、邮费模板管理、分组管理、货架管理、订单管理、功能接口）</li>\n<li>[ ] 模版消息</li>\n<li>[ ] 网址缩短</li>\n<li>[ ] 语义查询</li>\n<li>[ ] 数据分析</li>\n<li>[ ] JSSDK服务端支持</li>\n<li>[ ] 素材管理</li>\n<li>[ ] 摇一摇周边</li>\n</ul>\n<h2>项目地址</h2>\n<p><a href=\"https://github.com/notadd/nt-addon-wechatapi\">https://github.com/notadd/nt-addon-wechatapi</a>   欢迎一起来撸</p>\n</div>",
        "title": "基于 nest.js 的微信公众平台 API  （开发中）",
        "last_reply_at": "2018-11-19T04:38:57.791Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 111,
        "create_at": "2018-11-19T04:38:57.791Z",
        "author": {
            "loginname": "zuohuadong",
            "avatar_url": "https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"
        }
    },
    {
        "id": "5bee8798a05b0e0ae443bee5",
        "author_id": "580c1addc3fead57507172a9",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>想开发一个多人聊天app，weex和react native 哪个更好用？</p>\n</div>",
        "title": "weex和react native 哪个更好用？",
        "last_reply_at": "2018-11-19T04:12:48.564Z",
        "good": false,
        "top": false,
        "reply_count": 11,
        "visit_count": 462,
        "create_at": "2018-11-16T09:02:16.331Z",
        "author": {
            "loginname": "jowang2016",
            "avatar_url": "https://avatars1.githubusercontent.com/u/18169317?v=4&s=120"
        }
    },
    {
        "id": "5bee75debe1b120abac5a17f",
        "author_id": "5267d2e99df724eb6db4fc1e",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>这实际上是空间复杂度和实用性的权衡策略，也可能是各家对Unicode的早期实现的坑，很多技术都中招了，不光是JavaScript，Java也有这样的问题，MySQL也为此出现了utf8和utf8mb4诡异的两种数据类型。</p>\n<p>Unicode分基本多文种平面和辅助平面两部分，JavaScript使用UCS-2来表示Unicode字符的，也就是说基本多文种平面字符用1个JavaScript字符表示，辅助平面字符用2个JavaScript字符表示，所以在JavaScript中，‘𣎴’这个字符实际上是’\\ud84c\\udfb4’，输出length肯定就是2了。</p>\n<p>可以参考这篇文章<a href=\"https://www.w3ctech.com/topic/1869\">《JavaScript 的内部字符编码是 UCS-2 还是 UTF-16》</a></p>\n</div>",
        "title": "解答为什么'𣎴'.length输出2",
        "last_reply_at": "2018-11-19T04:02:44.453Z",
        "good": false,
        "top": false,
        "reply_count": 4,
        "visit_count": 366,
        "create_at": "2018-11-16T07:46:38.590Z",
        "author": {
            "loginname": "libook",
            "avatar_url": "https://avatars1.githubusercontent.com/u/3395610?v=4&s=120"
        }
    },
    {
        "id": "5bed0f3ba05b0e0ae443b681",
        "author_id": "5abf88b7679ac2ad2c492a06",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>在Sequelize官方文档中， 都是有关联的查询， 目前还没看到无关联的查询语句。\n除了用原生Sql， 在Sequelize中有语法可以实现吗？</p>\n</div>",
        "title": "Sequelize  无关联查询",
        "last_reply_at": "2018-11-19T03:57:43.577Z",
        "good": false,
        "top": false,
        "reply_count": 6,
        "visit_count": 290,
        "create_at": "2018-11-15T06:16:27.990Z",
        "author": {
            "loginname": "TimesDonegal",
            "avatar_url": "https://avatars0.githubusercontent.com/u/33818615?v=4&s=120"
        }
    },
    {
        "id": "5b5e78f5673571454c633cea",
        "author_id": "5b56866ae740336c7bedb345",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><strong>koa2实战项目介绍（真全栈）：</strong></p>\n<p><strong>Nodejs+koa2实战视频教程</strong>从零开始一步一步让你学会Koa基础以及用用<strong>Koa开发项目</strong>，本教程涉及 用户权限判断 、<strong>验证码</strong> 、分页、多级分类、<strong>ueditor可视化富文本编辑器</strong>、图片上传、<strong>底层DB库封装</strong>、<strong>扩展art-template的核心方法、<strong>ajax改变状态、ajax排序、以及赠送的</strong>Socket.io机器人</strong> 、Socket.io多人聊天室、<strong>Socket.io群聊</strong>、前后端分离 <strong>RESTful API Api</strong>接口、购买域名 服务器、域名备案、<strong>nginx负载均衡</strong>、<strong>域名解析部署nodejs程序</strong>、Nodejs进程管理器pm2模块、Koa操作<strong>mysql数据库</strong></p>\n<p><strong>地址：</strong> <a href=\"https://www.itying.com/goods-800.html\">Koa2实战视频教程下载地址点我</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址（41讲免费基础下载地址）：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n</div>",
        "title": "Nodejs+koa2实战视频教程【87讲】--Koa2+Nodejs+MongoDb打造企业级CMS前后端全栈项目实战视频教程",
        "last_reply_at": "2018-11-19T02:56:08.430Z",
        "good": false,
        "top": false,
        "reply_count": 53,
        "visit_count": 8142,
        "create_at": "2018-07-30T02:33:25.113Z",
        "author": {
            "loginname": "songsunli",
            "avatar_url": "https://avatars1.githubusercontent.com/u/41601667?v=4&s=120"
        }
    },
    {
        "id": "5bf0d719be1b120abac5a704",
        "author_id": "5a9a256b2ffb8598445aeabb",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><strong>目的</strong>:  加入或组建一个LoopBack交流群,方便学习和分享LoopBack使用经验\n<strong>注意</strong>: LoopBack有很多优点,同时也有很多坑</p>\n<p>参考链接:</p>\n<ul>\n<li><a href=\"https://loopback.io/\">LoopBack</a></li>\n</ul>\n<p>有群主可以拉我下或感兴趣的小伙伴可以加下:\n<img src=\"//static.cnodejs.org/Fv5YXA2Do8E4DWRyk-FBasBggwmW\" alt=\"WechatIMG34.jpeg\"></p>\n</div>",
        "title": "LoopBack框架交流群组建或加入",
        "last_reply_at": "2018-11-19T02:13:20.865Z",
        "good": false,
        "top": false,
        "reply_count": 3,
        "visit_count": 225,
        "create_at": "2018-11-18T03:06:01.086Z",
        "author": {
            "loginname": "keith666666",
            "avatar_url": "https://avatars1.githubusercontent.com/u/14068334?v=4&s=120"
        }
    },
    {
        "id": "5bf21601e6481c5709f5d00f",
        "author_id": "597ee3db68aa87c774e5edac",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fp7jQWj8QYcT86vdE0-u8IiafIQ1\" alt></p>\n<p>编者说：作为JS系工程师接触最多的漏洞我想就是 XSS 漏洞了，然鹅并不是所有的同学对其都有一个清晰的认识。今天我们请来了@卢士杰 同学为我们分享他眼中的 XSS 漏洞攻击，希望能帮助到大家。</p>\n<hr>\n<h2>什么是 XSS 攻击</h2>\n<p>XSS（Cross-Site Scripting）又称跨站脚本，XSS的重点不在于跨站点，而是在于脚本的执行。XSS是一种经常出现在 Web 应用程序中的计算机安全漏洞，是由于 Web 应用程序对用户的输入过滤不足而产生的。</p>\n<p>常见的 XSS 攻击有三种：反射型、DOM-based 型、存储型。 其中反射型、DOM-based 型可以归类为非持久型 XSS 攻击，存储型归类为持久型 XSS 攻击。</p>\n<h3>1.反射型</h3>\n<p>反射型 XSS 一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。</p>\n<p>对于访问者而言是一次性的，具体表现在我们把我们的恶意脚本通过 URL 的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。反射型 XSS 的触发有后端的参与，要避免反射性 XSS，必须需要后端的协调，后端解析前端的数据时首先做相关的字串检测和转义处理。</p>\n<p>此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</p>\n<p>整个攻击过程大约如下：</p>\n<p><img src=\"https://p4.ssl.qhimg.com/t01a98b7f389ece8c01.png\" alt=\"反射型\"></p>\n<h3>2.DOM-based 型</h3>\n<p>客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到 DOM-based XSS 攻击。需要特别注意以下的用户输入源 <code>document.URL</code>、<code>location.hash</code>、<code>location.search</code>、<code>document.referrer</code> 等。</p>\n<p>整个攻击过程大约如下：</p>\n<p><img src=\"https://p4.ssl.qhimg.com/t0165dddb475fc1e83c.png\" alt=\"DOM-based\"></p>\n<h3>3.存储型</h3>\n<p>攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。</p>\n<p>存储型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p>\n<p>整个攻击过程大约如下：</p>\n<p><img src=\"https://p0.ssl.qhimg.com/t017b61091f1c67ca05.png\" alt=\"DOM-based\"></p>\n<h2>XSS 攻击的危害</h2>\n<p>XSS 可以导致：</p>\n<ol>\n<li>攻击劫持访问；</li>\n<li>盗用 cookie 实现无密码登录；</li>\n<li>配合 csrf 攻击完成恶意请求；</li>\n<li>使用 js 或 css 破坏页面正常的结构与样式等；</li>\n</ol>\n<h2>防御方法</h2>\n<h3>1. XSS 防御之 HTML 编码</h3>\n<p>应用范围：将不可信数据放入到 HTML 标签内（例如div、span等）的时候进行HTML编码。</p>\n<p>编码规则：将 &amp; &lt; &gt; &quot; ’ / 转义为实体字符（或者十进制、十六进制）。</p>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-js\"><code>  function encodeForHTML(str, kwargs){\n    return (&#x27;&#x27; + str)\n      .replace(&#x2F;&amp;&#x2F;g, &#x27;&amp;amp;&#x27;)\n      .replace(&#x2F;&lt;&#x2F;g, &#x27;&amp;lt;&#x27;)     &#x2F;&#x2F; DEC=&gt; &amp;#60; HEX=&gt; &amp;#x3c; Entity=&gt; &amp;lt;\n      .replace(&#x2F;&gt;&#x2F;g, &#x27;&amp;gt;&#x27;)\n      .replace(&#x2F;&quot;&#x2F;g, &#x27;&amp;quot;&#x27;)\n      .replace(&#x2F;&#x27;&#x2F;g, &#x27;&amp;#x27;&#x27;)   &#x2F;&#x2F; &amp;apos; 不推荐，因为它不在HTML规范中\n      .replace(&#x2F;\\&#x2F;&#x2F;g, &#x27;&amp;#x2F;&#x27;);\n  };\n</code></pre><p>HTML 有三种编码表现方式：十进制、十六进制、命名实体。例如小于号（&lt;）可以编码为 “十进制&gt; &lt;”, “十六进制=&gt; &lt;”, “命名实体=&gt; &lt;” 三种方式。对于单引号（’）由于实体字符编码方式不在 HTML 规范中，所以此处使用了十六进制编码。</p>\n<h3>2. XSS 防御之 HTML Attribute 编码</h3>\n<p>应用范围：将不可信数据放入 HTML 属性时（不含src、href、style 和事件处理属性），进行 HTML Attribute 编码</p>\n<p>编码规则：除了字母数字字符以外，使用 &amp;#xHH;(或者可用的命名实体)格式来转义ASCII值小于256所有的字符​​​​​​​</p>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-js\"><code>  function encodeForHTMLAttibute(str, kwargs){\n    let encoded = &#x27;&#x27;;\n    for(let i = 0; i &lt; str.length; i++) {\n      let ch = hex = str[i];\n      if (!&#x2F;[A-Za-z0-9]&#x2F;.test(str[i]) &amp;&amp; str.charCodeAt(i) &lt; 256) {\n        hex = &#x27;&amp;#x&#x27; + ch.charCodeAt(0).toString(16) + &#x27;;&#x27;;\n      }\n      encoded += hex;\n    }\n    return encoded;\n  };\n</code></pre><h3>3. XSS 防御之 JavaScript 编码</h3>\n<p>作用范围：将不可信数据放入事件处理属性、JavaScirpt值时进行 JavaScript 编码</p>\n<p>编码规则：除字母数字字符外，请使用\\xHH格式转义ASCII码小于256的所有字符</p>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-js\"><code>  function encodeForJavascript(str, kwargs) {\n    let encoded = &#x27;&#x27;;\n    for(let i = 0; i &lt; str.length; i++) {\n      let cc = hex = str[i];\n      if (!&#x2F;[A-Za-z0-9]&#x2F;.test(str[i]) &amp;&amp; str.charCodeAt(i) &lt; 256) {\n        hex = &#x27;\\\\x&#x27; + cc.charCodeAt().toString(16);\n      }\n      encoded += hex;\n    }\n    return encoded;\n  };\n</code></pre><h3>4. XSS 防御之 URL 编码</h3>\n<p>作用范围：将不可信数据作为 URL 参数值时需要对参数进行 URL 编码</p>\n<p>编码规则：将参数值进行 encodeURIComponent 编码</p>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-js\"><code>  function encodeForURL(str, kwargs){\n    return encodeURIComponent(str);\n  };\n</code></pre><h3>5. XSS 防御之 CSS 编码</h3>\n<p>作用范围：将不可信数据作为 CSS 时进行 CSS 编码</p>\n<p>编码规则：除了字母数字字符以外，使用\\XXXXXX格式来转义ASCII值小于256的所有字符</p>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-js\"><code>  function encodeForCSS (attr, str, kwargs){\n    let encoded = &#x27;&#x27;;\n    for (let i = 0; i &lt; str.length; i++) {\n      let ch = str.charAt(i);\n      if (!ch.match(&#x2F;[a-zA-Z0-9]&#x2F;) {\n        let hex = str.charCodeAt(i).toString(16);\n        let pad = &#x27;000000&#x27;.substr((hex.length));\n        encoded += &#x27;\\\\&#x27; + pad + hex;\n      } else {\n        encoded += ch;\n      }\n    }\n    return encoded;\n  };\n</code></pre><h2>后记</h2>\n<p>在任何时候用户的输入都是不可信的。对于 HTTP 参数，理论上都要进行验证，例如某个字段是枚举类型，其就不应该出现枚举以为的值；对于不可信数据的输出要进行相应的编码；此外<code>httpOnly</code>、<code>CSP</code>、<code>X-XSS-Protection</code>、<code>Secure Cookie</code> 等也可以起到有效的防护。</p>\n<p>XSS 漏洞有时比较难发现，所幸当下React、Vue等框架都从框架层面引入了 XSS 防御机制，一定程度上解放了我们的双手。\n但是作为开发人员依然要了解 XSS 基本知识、于细节处避免制造 XSS 漏洞。框架是辅助，我们仍需以人为本，规范开发习惯，提高 Web 前端安全意识。</p>\n<h2>参考文档</h2>\n<ul>\n<li><a href=\"http://www.qa-knowhow.com/?p=1467\">http://www.qa-knowhow.com/?p=1467</a></li>\n<li><a href=\"https://brajeshwar.github.io/entities/\">https://brajeshwar.github.io/entities/</a></li>\n<li><a href=\"https://excess-xss.com/\">https://excess-xss.com/</a></li>\n<li><a href=\"https://github.com/chrisisbeef/jquery-encoder\">https://github.com/chrisisbeef/jquery-encoder</a></li>\n</ul>\n</div>",
        "title": "Web 安全漏洞之 XSS 攻击",
        "last_reply_at": "2018-11-19T01:46:41.382Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 122,
        "create_at": "2018-11-19T01:46:41.382Z",
        "author": {
            "loginname": "lizheming",
            "avatar_url": "https://avatars2.githubusercontent.com/u/424491?v=4&s=120"
        }
    },
    {
        "id": "5ba259a315e4fd1923f4891f",
        "author_id": "5b509c2ffb9e84ec69cc1c2d",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><strong>Mongodb+Mongoose中高级教程下载地址【20讲】：</strong> <a href=\"https://pan.baidu.com/s/1Dva3FBLYILWSPubHy8kOFA\">https://pan.baidu.com/s/1Dva3FBLYILWSPubHy8kOFA</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址【41讲】：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n<p><strong>地址失效访问：</strong>：<a href=\"https://www.itying.com/goods-800.html\">地址失效点我</a></p>\n<p>希望老铁们喜欢。上面都是百度网盘直接下载哦！</p>\n<p><strong>MongoDB视频教程包括：</strong></p>\n<p>MongoDB安装、MongoDB增删改查、MongoDB索引、MongoDB权限管理、MongoDB聚合管道、MongoDB aggregate聚合管道 多表关联查询。</p>\n<p><strong>Mongoose视频教程包括：</strong></p>\n<p>Mongoose的安装、mongoose增删改查、mongoose默认参数 、mongoose模块化、Mongoose 预定义模式修饰符、自定义修饰符、Mongoose索引、扩展Mongoose内置查询方法、Mongoose 数据校验、Mongoose两个表关联查询aggregate、MongooseN个表关联查询aggregate、Mongoose、 DBRef  Populate。</p>\n</div>",
        "title": "【网盘分享】Mongodb+Mongoose中高级教程涉及mongodb用户权限验证、Mongodb aggregate聚合管道（多集合关联查询）Mongoose入门实战",
        "last_reply_at": "2018-11-19T00:35:08.289Z",
        "good": false,
        "top": false,
        "reply_count": 16,
        "visit_count": 1301,
        "create_at": "2018-09-19T14:13:55.479Z",
        "author": {
            "loginname": "gogogosns",
            "avatar_url": "https://avatars2.githubusercontent.com/u/41439393?v=4&s=120"
        }
    },
    {
        "id": "5bec3714a05b0e0ae443b366",
        "author_id": "5bc9f0ca9545eaf107b9ccdd",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>学前端需要哪些知识</p>\n</div>",
        "title": "如何学好前端",
        "last_reply_at": "2018-11-18T12:14:23.693Z",
        "good": false,
        "top": false,
        "reply_count": 5,
        "visit_count": 504,
        "create_at": "2018-11-14T14:54:12.824Z",
        "author": {
            "loginname": "hhffhh",
            "avatar_url": "https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"
        }
    },
    {
        "id": "5b7f8a2c944cb8340c27e335",
        "author_id": "5b72f6727271129a2f32a97f",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>2018年Nodejs Koa2 Typescript Eggjs Vue2最新教程资源网盘分享：\n<a href=\"https://pan.baidu.com/s/1O2C6TolDzYpMnKIfQaaqog\">Nodejs视频教程</a>\n<a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">Koa2教程</a>\n<a href=\"https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg\">6月Typescript教程</a>\n<a href=\"https://pan.baidu.com/s/1a8-RY-aBm3YkH2ZqJKmztg\">8月Eggjs视频教程</a>\n需要更多学习资源可留下邮箱，有的就分享</p>\n</div>",
        "title": "2018年Nodejs Koa2 Typescript Eggjs Vue2最新教程资源网盘分享",
        "last_reply_at": "2018-11-18T09:08:11.738Z",
        "good": false,
        "top": false,
        "reply_count": 25,
        "visit_count": 3262,
        "create_at": "2018-08-24T04:31:40.973Z",
        "author": {
            "loginname": "chengl123",
            "avatar_url": "https://avatars3.githubusercontent.com/u/42384077?v=4&s=120"
        }
    },
    {
        "id": "5bf11eebe6481c5709f5cd5f",
        "author_id": "5af504420a36e5312d6ecf95",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>Node中的子进程模块可以输入一些shell命令来完成一些事情\n比如查看当前目录的文件：\n<img src=\"//static.cnodejs.org/FsEywBlx5M_kqMV2ea8seqA_h_Mf\" alt=\"screenshot.png\">\n但如果有一个命令需要执行后再次输入比如密码之类的子命令，应该如何通过该模块实现？或者不通过该模块如何实现？</p>\n</div>",
        "title": "在Node中，如何用子进程模块完成一个有交互的命令？",
        "last_reply_at": "2018-11-18T08:12:27.075Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 171,
        "create_at": "2018-11-18T08:12:27.075Z",
        "author": {
            "loginname": "Masterlu1998",
            "avatar_url": "https://avatars3.githubusercontent.com/u/35906426?v=4&s=120"
        }
    },
    {
        "id": "5beedcabbe1b120abac5a41a",
        "author_id": "5bc9f0ca9545eaf107b9ccdd",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>有没有推荐前端原生js书本，适合这几年的</p>\n</div>",
        "title": "有没有推荐前端原生js书本",
        "last_reply_at": "2018-11-18T07:49:39.026Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 273,
        "create_at": "2018-11-16T15:05:15.595Z",
        "author": {
            "loginname": "hhffhh",
            "avatar_url": "https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"
        }
    },
    {
        "id": "5b18a28557137f22415c49e9",
        "author_id": "55d120f3b25bd72150842d85",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h1>前端进阶之困</h1>\n<p>最近看了不少文章和帖子， 如文：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5b124fdd5188257d6c0465da?utm_source=gold_browser_extension\">前端的焦虑，你想过30岁以后的前端路怎么走吗？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5af047150a36e5312d6ecdf0\">前端怎么一步步走向全栈呢？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5b164efa29e6e510415b2803\">移动端入门Node.js怎么学习?</a></li>\n<li><a href=\"https://cnodejs.org/topic/5a4cc04cebc575dc49b270d5\">前端的未来走向在哪里？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5ab1ebb5e7b166bb7b9eccaa\">工作2年多的前端，现在迷茫了，如何更进一步的提升自己</a></li>\n</ul>\n<p>身边和朋友圈也不少做前端开发的同事朋友问如何发展和提升\n这里我向大家给一些建议</p>\n<h2>扎实基础</h2>\n<p>首先思考下手上的工作是否做得足够好了，近几年前端技术发展迅猛各种框架层出不穷，刚学会jquery还没用熟， angular 、vue 、react 已经满大街了。\ngulp 还没明白怎么回事、webpack 已开始遍地开花了。眼花缭乱的技术不知道从哪里开始好。\n如果你还被这些困扰的话，那请静下来思考一下，技术的发展总是有规律的，学习也是有规律可循的，我的建议是，把共性和必要的技能先稳固下来，既不浪费时间，又能提高效率，如果这块还么稳固好、框架什么少看几种吧，先有一样可用的就好。\n对于加强基础一个可行的方案是，从自己上手的工作开始、除了专注现学现用工作需要的框架技术外加强基础的学习，如：</p>\n<ul>\n<li>基本的逻辑（与、或、非）</li>\n<li>运算操作（加减乘除 Math 下的各种函数）</li>\n<li>字符串处理 （什么大小写、编码、裁剪什么的）</li>\n<li>时间处理 （日期的加减、对比、格式转换等）</li>\n<li>数组、集合对象处理\n可以了解学习一些基础库 如: <a href=\"https://github.com/lodash/lodash\">lodash</a>、<a href=\"https://github.com/moment/moment\">moment</a> 等、若时间有限可以看看示例有个印象回头可以查找，当然最好的方式是实践练习。</li>\n</ul>\n<h2>发展全栈的正确姿势</h2>\n<p>Javascript 生态链对于全栈有一些优势，但全栈不是贴金的标签，如果技能不够硬，必然落得个 <strong>前端不强，后端不行</strong> 的尴尬局面。</p>\n<h3>那对于前端是不是不该发展后端呢？</h3>\n<p>回答当然是否定的，前端<em>有目的、有计划的发展后端技能</em>，对于系统全局观、工作协作能力提升是非常有帮助的，<strong>另外切实让老板愿意为你加工资是非常可能的</strong>。</p>\n<h3>那要如何才能是有目的、有计划的发展后端技能呢？</h3>\n<p>首先认清后端技能出发点和关键点。</p>\n<ul>\n<li>出发点: 是主动权和话语权（可能某个后端老是鄙视你，你要的东西，说这个没办法，那个不应该，造成了你工作很被动，效率不高，出错了可能还先找你）。</li>\n<li>关键点: 前后端接口 （如果你能清晰、标准、明确你要的接口，那么一些都会明朗起来）。\n所以我认为前端切入后端应该从接口开始。</li>\n</ul>\n<h3>从标准接口开始，什么样的接口才是标准的呢？</h3>\n<p><a href=\"https://swagger.io/resources/open-api/\">OpenAPI  Specification</a>\n这里我为大家推荐 Swagger 标准接口 (目前有两个标准 OAS 2.0 和 OAS 3.0)\nSwagger 致力于接口的标准化，并为此提供了一系列的工具，方便大家对进口进行标准化。</p>\n<h3>有什么好处呢</h3>\n<ul>\n<li>简化工作流程 (Streamline Your Workflow)。</li>\n<li>自由构建 (Restraint-Free Build)</li>\n<li>开放/全球化的支持 (Open &amp; Globally Supported)\n我的理解是增强系统的健壮性、降低沟通成本、提高写作效率，另外接口是系统的一种抽象可以更好的从宏观把握系统。</li>\n</ul>\n<h3>标准化的接口要如何实践</h3>\n<p>这里我安利下我的开源项目 <a href=\"https://github.com/vellengs/typerx\">typerx</a>, typerx 是一个轻量注解式的全栈系统、你可以使用他快速的实践接口标准的全栈开发。</p>\n<ul>\n<li>创建接口前、我们仍旧还是要考虑接口模块的、模块化的设计能降低我们一次思考的复杂度。\n在 typerx 中我们分了 core 模块和 cms 模块。</li>\n<li>接口的创建从原型开始考虑、确定接口所需的模型 model, 这个模型我们称之为 DTO(data transform object) 也就是接口的输入输出数据对象。\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/dto\">dto 的编写示例</a></li>\n<li>有了模型之后我们就可以确定需要哪些接口方法了，编写接口的时候先不着急考虑接口的实现，我们只要先提供模型（可以建立一个按模型提供的数据mock)确保必要的接口规格描述就好，\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/account.controller.ts\">account 的接口定义</a>\n这里我们通过直接编写代码的方式来实现文档，这样方便我们高效、可维护的接口文档（当然先完成文档再来生成代码也是可以的，不过代码能表述的永远比文档能描述的多，所以应该是有一套能够自动生成api 文档的代码来维护比较合适，过去也曾从文档开始，但文档的错漏不方便验证、而且文档维护数据模型是很累的一个事情无法动态关联重构）。</li>\n<li>按要求完成了接口定义之后，你只要轻松运行</li>\n</ul>\n<pre class=\"prettyprint\"><code>npm run build \n</code></pre><p>你就拥有标准的接口文档描述文件 swagger.json / swagger.yaml 了, 你可以使用 typerx 直接启动服务端预览接口 <a href=\"http://localhost:4700/docs\">localhost:4700</a> 或者放到在线编辑器上预览 <a href=\"http://editor.swagger.io/\">editor.swagger.io</a>;</p>\n<ul>\n<li>好了标准话的接口有了你可以保持这个接和后端的接口一致，这样就可以和后端愉快的协作了，当然如果你喜欢，直接使用 typerx 实现自己真实的后端。</li>\n</ul>\n<p>最后欢迎大家关注 <a href=\"https://github.com/vellengs/typerx\">typerx</a> 一起讨论努力进阶。</p>\n</div>",
        "title": "前端如何进阶全栈开发",
        "last_reply_at": "2018-11-18T02:29:36.766Z",
        "good": false,
        "top": false,
        "reply_count": 32,
        "visit_count": 6382,
        "create_at": "2018-06-07T03:12:05.854Z",
        "author": {
            "loginname": "vellengs",
            "avatar_url": "https://avatars1.githubusercontent.com/u/5743338?v=4&s=120"
        }
    },
    {
        "id": "5bf018a7be1b120abac5a63a",
        "author_id": "57957de04265959826e7b25b",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>最近在学习express，在学习期间遇到一些问题，想不清楚想向各位请教一下。</p>\n<ol>\n<li>在首次登陆token后，后端生成token，这里token存储在数据库中还是redis中较为合适。</li>\n<li>如果后端把token存在redis中，前段携带sign请求接口，此时如果后端将token以sign：token的方式存储在redis中，如果前段携带的sign不存在，重新生成token签名存储在redis中，旧的签名如何处理。</li>\n<li>项目需要实现可视化配置api接口状态，以及角色是否拥有访问该接口的权限功能，这里生成用户的token，是否需要将用户所属的角色以及角色所拥有的接口权限，一起生成一个签名。</li>\n<li>某些接口需要鉴权，某些接口不需要，比如登陆接口，以及注册接口就不需要鉴权，我想实现某些需要鉴权的接口认证token以及角色权限，接口状态，参数验证等功能。而登陆接口我只想验证接口状态，接口参数验证，这种情况应该如何处理。\n因为本人首次接触后端，很多知识不了解，通过百度等搜索几乎没有nodejs的案例讲解，希望诸位解释一下，如果有demo那就更好了，哭泣脸。\n谢谢ll</li>\n</ol>\n</div>",
        "title": "关于token的一些疑问",
        "last_reply_at": "2018-11-18T01:19:08.918Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 204,
        "create_at": "2018-11-17T13:33:27.183Z",
        "author": {
            "loginname": "zhang962976642",
            "avatar_url": "https://avatars1.githubusercontent.com/u/16224118?v=4&s=120"
        }
    },
    {
        "id": "5bb0bf6f37a6965f59051df3",
        "author_id": "5ba61ea38f5b0c1c59ea10b6",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h2>首先直接来看下最终的效果图吧：</h2>\n<h3>网站首页：</h3>\n<p><img src=\"//static.cnodejs.org/FiJw4MA02y3lTpz3lpvZUldUJ-np\" alt=\"index.jpg\">\n<img src=\"//static.cnodejs.org/FgrY7ewT5eEc3kw-GIPPc-f-dIox\" alt=\"tv.jpg\"></p>\n<h3>播放页面：</h3>\n<p><img src=\"//static.cnodejs.org/FryrTyzEeEFuOgD1uXrkwF4MzXn-\" alt=\"play.jpg\">\n<img src=\"//static.cnodejs.org/FunbF8tDdXmeegGuLPAO-ZTY8p8B\" alt=\"00.jpg\"></p>\n<h3>评论页面：</h3>\n<p><img src=\"//static.cnodejs.org/FiPYJ4tN3lyjQOJeaTbDN8mqpCKb\" alt=\"comment.jpg\"></p>\n<h3>搜索页面：</h3>\n<p><img src=\"//static.cnodejs.org/FiwL6aQpZBKV4HktP-J1oVYUZM5B\" alt=\"search.jpg\"></p>\n<h3>登录页面：</h3>\n<p><img src=\"//static.cnodejs.org/FrZr5Mck4VQD9ndVXhJGqA9XwHsU\" alt=\"login.jpg\"></p>\n<h3>注册页面：</h3>\n<p><img src=\"//static.cnodejs.org/FnXwM1CtMBcA7cFv66vlYb-t559E\" alt=\"register.jpg\"></p>\n<h3>用户中心：</h3>\n<p><img src=\"//static.cnodejs.org/FtCfCUeeIA8Y0WnYkhvzqlweqPbs\" alt=\"user.jpg\"></p>\n<h2></h2>\n<p>项目名称：VIP视频网站项目\n开发语言：HTML，CSS（前端），JavaScript，NODEJS（expres）（后台）\n数据库：MySQL\n开发环境：Win7，Webstorm\n上线环境：Linux服务器\n在线演示站点：<a href=\"http://vip.52tech.tech\">http://vip.52tech.tech</a>\nGithub源码：<a href=\"https://github.com/xiugangzhang/vip.github.io\">https://github.com/xiugangzhang/vip.github.io</a></p>\n<h1>VIP视频网站项目基本介绍</h1>\n<h2>程序安装方法</h2>\n<ul>\n<li>确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），然后下载此安装包后解压到你的系统任意盘符下面的目录；</li>\n<li>在当前解压文件夹的主目录（包含package.json的那个文件夹）运行命令：npm install， 系统就会自动安装该程序的依赖包；</li>\n<li>登录你的网站数据库管理界面（PHPAdmin）,如果是在本地测试的话，就使用Navicat等MYSQL数据库连接工具连接数据库，连接完成之后创建数据库名为video，设置数据库登录名root， 登录密码为123456。如果需要配置其他用户名或者密码，请进入到modes/db.js文件下面，修改代码11行/12行的位置，user和password改为你自己的用户名个密码就行；</li>\n<li>数据库环境配置完成之后，打开解压文件夹里面的video.sql数据库脚本文件，进入Navicat等数据库管理工具，运行执行脚本文件，脚本执行成功之后就会在已经创建好的数据库下面创建程序运行所需要的数据表文件；</li>\n<li>在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,先打开app.js文件，然后找到代码：server.listen(8080, ‘192.168.1.101’, function () {})，修改为你自己的主机相应的IP地址和端口号，然后执行命令，node app.js，在以上的配置都没出错的情况下，这里就会正常启动程序了，然后进入浏览器，输入IP地址和端口号，就会进入到程序的主页了。</li>\n<li>初次进入到网站首页后，由于数据库中没有数据的原因，首页或者其他页面可能会出现变形格式不正常等其他问题，大家可以向数据库中添加一些测试数据，然后再测试一下。这里也可以直接添加我这里提供的一些测试数据，参见相关文件夹下面的video.sql 文件（直接导入数据表结构），如果是需要导入内容文件，这里也提供了另外一个SQL文件（包含部分内容的数据表movies.sql和tvs.sql）,直接使用数据库管理工具，导入SQL文件数据到数据库即可完成数据的导入。</li>\n</ul>\n<h2>当前版本 V1.0.0</h2>\n<h2>主要功能</h2>\n<ul>\n<li>用户主页的搭建：\n<ul>\n<li>实现了主页轮播图的显示和切换，用户可以从数据库中自由配置和切换轮播图的显示</li>\n<li>实现了主页电影列表的显示：从数据库文件读取电影和电视剧列表信息并在前台显示</li>\n</ul>\n</li>\n<li>用户登录和注册页面的搭建：\n<ul>\n<li>实现了用户的登录和注册功能</li>\n</ul>\n</li>\n<li>用户注册和登录验证码提示功能</li>\n<li>用户登录注册验证码机制</li>\n<li>电影播放页面的搭建\n<ul>\n<li>对于其他页面的任意可以展现电影列表的页面，用户可以直接点击列表，直接进入播放页面</li>\n<li>播放页面电影详细信息的展现</li>\n<li>对于加载速度较慢的视频，用户可以自由切换播放接口进行加速</li>\n<li>弹幕功能（特色功能）：类似于B站等其他视频网站的弹幕功能，用户在登录之后可以实现在线发言</li>\n<li>用户可以在相应的播放页面查看其他用户已经发表的评论，同时也可以在登录之后自由发表评论</li>\n<li>电影收藏和取消功能</li>\n</ul>\n</li>\n<li>用户中心的管理\n<ul>\n<li>对于已经注册的用户，实现用户基本信息的修改</li>\n<li>用户密码的修改</li>\n<li>用户评论记录的查看</li>\n<li>用户收藏电影的查看和播放</li>\n<li>用户登录日志的查看</li>\n</ul>\n</li>\n<li>电影搜索功能（特色功能）\n<ul>\n<li>实现了根据视频播放地址和视频名称全网视频的搜索和播放功能</li>\n<li>实现了正在热映，即将上映和TOP250的电影列表的展示</li>\n</ul>\n</li>\n<li>其他</li>\n<li>页面整体的风格模仿了Discuz等论坛网站的布局</li>\n<li>网站首页的轮播图效果模仿了优酷、爱奇艺、腾讯视频等主流视频网站的轮播图效果</li>\n<li>电影底部的的友情链接，使用了大部分网站的分栏布局，用户可以添加自己的QQ群以及微信公众号方便增加自己网站的人气</li>\n<li>主要列表的分页功能，对于一些内容显示较多的不能再一页显示完整的页面，使用了ajax无刷新分页对数据进行多条展示，提高了用户的体验</li>\n<li>目前主流浏览器中也做了相应测试，建议大家使用谷歌或者火狐浏览器，效果可能会更好</li>\n</ul>\n<h2>其他说明</h2>\n<ul>\n<li>总的来说吧，自己就是一个对前端技术有着较高热情的小白吧，没事的时候喜欢瞎折腾，对一些有意思的技术平时也比较喜欢研究一下吧。因此就在这股热情的鼓励下，怀着满腔热血，写下了这个VIP视频网站项目程序。因为发现有些东西一旦落下来，后面就也没有太多的激情去继续完善这个程序了，就把这个程序贡献给开源社区吧，供大家学习交流使用，在这里也希望大家能够多多支持。</li>\n<li>最后，也请大家尊重原创，转载请注明出处。此外，由于时间原因以及个人能力有限等其他原因，目前程序中可能也会存在一些潜在的bug，对于程序中的一些技术细节或者其他问题，也欢迎大家多多交流，也欢迎大家提出来，后面也可以抽时间继续维护这个项目，如果可以的话后面大家可以继续维护吧。有什么问题或者建议也欢迎大家在下面留言。</li>\n</ul>\n</div>",
        "title": "【VIP视频网站项目】基于Nodejs的Express框架开发的VIP视频网站项目及源码分享",
        "last_reply_at": "2018-11-17T20:36:03.414Z",
        "good": false,
        "top": false,
        "reply_count": 4,
        "visit_count": 10497,
        "create_at": "2018-09-30T12:19:59.585Z",
        "author": {
            "loginname": "xiugangzhang",
            "avatar_url": "https://avatars3.githubusercontent.com/u/29092258?v=4&s=120"
        }
    },
    {
        "id": "5bf04e4bbe1b120abac5a6ac",
        "author_id": "5a9c18e28edf56a344937054",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><blockquote>\n<p>vuepress 是 Vue 驱动的静态站点生成工具</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>本文仅介绍，搭建静态博客的过程，具体教程及文档请点击进入 <a href=\"https://www.vuepress.cn/\" title=\"vuepress\">vuepress中文网</a></strong></p>\n</li>\n<li>\n<p><a href=\"https://zhb333.github.io/readme-blog/\" title=\"张焕标的博客\">点击进入博客</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/zhb333/readme-blog\" title=\"zhb333/readme-blog\">点击查看项目代码</a></p>\n</li>\n</ul>\n<h2>vuepress初始化</h2>\n<h3>下面初始化</h3>\n<pre class=\"prettyprint language-sh\"><code># 将 github 新创建的仓库克隆到本地\ngit clone git@github.com:zhb333&#x2F;readme-blog.git\n\n# 进入项目\ncd readme-blog\n\n# npm 初始化, 按照提示回车\nnpm init\n\n# 安装 vuepress\nnpm i vuepress -D\n\n# 安装 gh-pages\nnpm i gh-pages -D\n\n# 创建一个 docs 目录\nmkdir docs\n\n# 创建一个 markdown 文件\necho &#x27;# Hello VuePress&#x27; &gt; docs&#x2F;README.md\n</code></pre><h3>npm 脚本</h3>\n<p>然后，给 <code>package.json</code> 添加一些 <code>scripts</code> 脚本：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;vuepress dev docs&quot;,\n    &quot;build&quot;: &quot;vuepress build docs&quot;,\n    &quot;deploy&quot;: &quot;npm run build &amp;&amp; gh-pages -d docs&#x2F;.vuepress&#x2F;dist&quot;\n  }\n}\n</code></pre><h3>运行本地开发环境</h3>\n<p>运行 <code>vurepress</code> 的本地开发环境</p>\n<pre class=\"prettyprint language-sh\"><code>npm run dev\n</code></pre><p>访问 <code>localhost:8080</code> ， 已经成功开启</p>\n<h2>基础配置</h2>\n<h3>生成静态资源</h3>\n<p>执行下面的命令，生成静态资源</p>\n<pre class=\"prettyprint language-sh\"><code>npm run build\n</code></pre><p>默认情况下，构建的文件会位于 <strong>docs/.vuepress/dist</strong> 中，该文件可以通过 <strong>docs/.vuepress/config.js</strong> 中的 <code>dest</code> 字段进行配置。</p>\n<h3>配置</h3>\n<p>创建 <strong>docs/.vuepress/config.js</strong>， 并进行简单配置</p>\n<pre class=\"prettyprint language-js\"><code>var config = {\n\n  &#x2F;&#x2F; 静态网站部署的目录\n  base: &#x27;&#x2F;readme-blog&#x2F;&#x27;,\n\n  &#x2F;&#x2F; 网站标题\n  title: &#x27;标 の 博客&#x27;,\n\n  &#x2F;&#x2F; &lt;meta name=&quot;description&quot; content=&quot;...&quot;&gt;\n  description: &#x27;种一棵树最好的时间是十年前，其次是现在&#x27;, \n\n  markdown: {\n    \n    &#x2F;&#x2F; 显示代码行号\n    lineNumbers: true\n  }\n}\n\nmodule.exports = config\n</code></pre><h2>博客首页</h2>\n<h3>公共文件</h3>\n<p>创建 <strong>docs/.vuepress/public</strong> 用于存放公共文件</p>\n<p>我在 <strong>public/</strong> , 存在了 <strong>favicon.ico</strong> 图标， 以及 <strong>zlx.jpg</strong> 首页的头像图片</p>\n<h3>简单的首页编写</h3>\n<p>将 <strong>docs/README.md</strong>设置为首页， 修改代码为：</p>\n<pre class=\"prettyprint language-md\"><code>---\nhome: true\nheroImage: &#x2F;zlx.jpg\nfooter: MIT Licensed | Copyright © 2018 ZhangHuanbiao\n---\n</code></pre><h3>设置网站 ico 图标</h3>\n<p>配置网站的 <strong>ico</strong> 图标， 修改 <strong>.vuepress/config.js</strong>：</p>\n<pre class=\"prettyprint language-js{2,3,4}\"><code>const config = {\n  head: [\n    [&#x27;link&#x27;, { rel: &#x27;icon&#x27;, href: &#x27;&#x2F;favicon.ico&#x27; }]\n  ]\n}\n</code></pre><h2>导航栏</h2>\n<h3>配置导航栏</h3>\n<p>使用 <strong>vuepress</strong> 的默认主题配置导航栏 <strong>.vuepress/config.js</strong>：</p>\n<pre class=\"prettyprint language-js{21}\"><code>const nav = [\n  {\n    text: &#x27;前端栈&#x27;,\n    items: [\n      { text: &#x27;Vue&#x27;, link: &#x27;&#x2F;WEB&#x2F;Vue&#x2F;vuepress-blog&#x27; },\n      { text: &#x27;React&#x27;, link: &#x27;&#x2F;WEB&#x2F;React&#x2F;react-router&#x27; }\n    ]\n  }\n]\n\nconst config = {\n  themeConfig: {\n\n    &#x2F;&#x2F; 项目的 github 地址\n    repo: &#x27;zhb333&#x2F;readme-blog&#x27;,\n\n    &#x2F;&#x2F; github 地址的链接名\n    repoLabel: &#x27;代码&#x27;,\n\n    &#x2F;&#x2F; 配置导航栏\n    nav,\n  },\n}\n</code></pre><h3>创建有效的导航资源</h3>\n<p>为了使得导航栏的链接点击有效， 我们创建两个文件：</p>\n<p><strong>docs/WEB/Vue/vuepress-blog.md</strong></p>\n<pre class=\"prettyprint language-md\"><code># 使用&#96;vuepress&#96;搭建静态博客\n\n## vuepress初始化\n\n## 基础配置\n\n## 博客首页\n\n## 导航栏\n</code></pre><p><strong>docs/WEB/React/react-router.md</strong></p>\n<pre class=\"prettyprint language-md\"><code># react-router\n</code></pre><h2>侧边栏</h2>\n<h3>侧边栏配置</h3>\n<p>使用 <strong>vuepress</strong> 的默认主题配置侧边栏 <strong>.vuepress/config.js</strong>：</p>\n<pre class=\"prettyprint language-js{23,24,39}\"><code>const sidebar = {\n  &#x27;&#x2F;WEB&#x2F;&#x27;: [\n    {\n      title: &#x27;Vue&#x27;,\n      children: [\n        &#x27;Vue&#x2F;vuepress-blog&#x27;\n      ]\n    },\n\n    {\n      title: &#x27;React&#x27;,\n      children: [\n        &#x27;React&#x2F;react-router&#x27;\n      ]\n    }\n  ]\n}\n\nconst nav = [\n  {\n    text: &#x27;前端栈&#x27;,\n    items: [\n      { text: &#x27;Vue&#x27;, link: &#x27;&#x2F;WEB&#x2F;&#x27; + sidebar[&#x27;&#x2F;WEB&#x2F;&#x27;][0][&#x27;children&#x27;][0] },\n      { text: &#x27;React&#x27;, link: &#x27;&#x2F;WEB&#x2F;&#x27; + sidebar[&#x27;&#x2F;WEB&#x2F;&#x27;][1][&#x27;children&#x27;][0] }\n    ]\n  }\n]\n\nvar config = {\n  themeConfig: {\n\n    &#x2F;&#x2F; 当前 markdown 的 github 代码链接\n    editLinks: true,\n\n    &#x2F;&#x2F; 链接显示的文本\n    editLinkText: &#x27;查看原文|编辑此页&#x27;,\n\n    nav,\n    sidebar,\n  },\n}\n</code></pre><h3>侧边栏效果</h3>\n<p>访问： <strong><a href=\"http://localhost:8080/readme-blog/WEB/Vue/vuepress-blog.html\">http://localhost:8080/readme-blog/WEB/Vue/vuepress-blog.html</a></strong>， 可以看到侧边栏已经生成</p>\n<h2>将静态博客网站部署到外网</h2>\n<p>使用 <strong>gh-pages</strong> 进行项目部署</p>\n<pre class=\"prettyprint language-sh\"><code>npm run deploy\n</code></pre><p>过几分钟后，访问 <strong><a href=\"https://zhb333.github.io/readme-blog/\">https://zhb333.github.io/readme-blog/</a></strong>， 便可以看到在外网成功部署的静态博客</p>\n<h2>评论功能</h2>\n<p>我们使用 <strong>valine</strong> 来实现评论功能：</p>\n<blockquote>\n<p>Valine - 一款快速、简洁且高效的无后端评论系统。</p>\n</blockquote>\n<p><strong>点击进入 <a href=\"https://valine.js.org/quickstart.html\" title=\"Valine\">Valine官网</a> ，需要先注册才能食用</strong></p>\n<h3>安装 Valine</h3>\n<pre class=\"prettyprint language-sh\"><code># Install leancloud&#x27;s js-sdk\nnpm install leancloud-storage --save\n\n# Install valine\nnpm install valine --save\n</code></pre><h3>注册 vuepress 全局组件</h3>\n<p>创建 <strong>.vuepress/components/Valine.vue</strong></p>\n<pre class=\"prettyprint language-html\"><code>&lt;template&gt;\n  &lt;div id=&quot;vcomments&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &#x27;Valine&#x27;,\n  mounted: function(){\n    &#x2F;&#x2F; require window \n    const Valine = require(&#x27;valine&#x27;);\n    if (typeof window !== &#x27;undefined&#x27;) {\n      this.window = window\n      window.AV = require(&#x27;leancloud-storage&#x27;)\n      \n    }\n     \n    new Valine({\n      el: &#x27;#vcomments&#x27; ,\n      appId: &#x27;&#x27;,&#x2F;&#x2F; your appId\n      appKey: &#x27;&#x27;, &#x2F;&#x2F; your appKey\n      notify:false, \n      verify:false, \n      avatar:&#x27;mm&#x27;, \n      placeholder: &#x27;just go go&#x27; \n    });\n  },\n}\n&lt;&#x2F;script&gt;\n</code></pre><h3>使用 Valine</h3>\n<p>只需要在 <strong>markdown</strong> 中调用即可</p>\n<pre class=\"prettyprint language-md\"><code>&lt;Valine&gt;&lt;&#x2F;Valine&gt;\n</code></pre></div>",
        "title": "Vuepress 搭建带评论功能的静态博客",
        "last_reply_at": "2018-11-17T17:22:19.364Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 173,
        "create_at": "2018-11-17T17:22:19.364Z",
        "author": {
            "loginname": "zhb333",
            "avatar_url": "https://avatars2.githubusercontent.com/u/26917599?v=4&s=120"
        }
    },
    {
        "id": "5b3e2e8c35342ab069061298",
        "author_id": "587599e6e65101c634fc9644",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>子系统的注销按钮，是跳转到 SSO 的注销接口地址， 然后 SSO 清除cookie,然后 通知（发送 http 请求）给子系统清除 session。</p>\n<p>但是当重新刷新子系统页面的时候，session 还是存在的， 尴尬，</p>\n<p>注销的代码如下， 求大佬指教</p>\n<p><img src=\"//static.cnodejs.org/FtvN5XV0m3kTGWYgB28Lpnob8kqh\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FqLzwoaM1NA9DC9w4n_WKfxjGG67\" alt=\"image.png\"></p>\n</div>",
        "title": "关于 SSO 单点注销， SSO如何通知子系统清除凭证？",
        "last_reply_at": "2018-11-17T11:11:15.561Z",
        "good": false,
        "top": false,
        "reply_count": 11,
        "visit_count": 1729,
        "create_at": "2018-07-05T14:43:24.397Z",
        "author": {
            "loginname": "zhongxia245",
            "avatar_url": "https://avatars0.githubusercontent.com/u/7597581?v=4&s=120"
        }
    },
    {
        "id": "5a62b395afa0a121784a8de0",
        "author_id": "590d7e623504ce1c2ac45912",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h2>JavaScript 中基础数据类型</h2>\n<table>\n<thead>\n<tr>\n<th>数据类型名称</th>\n<th>数据类型说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Undefined</td>\n<td>只有一个值，即 <code>undefined</code>，声明变量的初始值。</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>只有一个值，即 <code>null</code>，表示空指针，<code>undefined</code> 的值是派生 <code>null</code> 的值。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>由零或多个 16 位 <code>Unicode</code> 字符组成</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>只有两个值，即 <code>true</code> 和 <code>false</code></td>\n</tr>\n<tr>\n<td>Number</td>\n<td>该类型使用 <code>IEEE754</code> 来表示整数和浮点数。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>ECMAScript 中的对象其实就是一组数据和功能的集合。</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>ES6 中新加入的数据类型，表示独一无二的值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>其中 <code>Object</code> 类型包含 <code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>。</strong></p>\n<h2>JavaScript 中的内置对象</h2>\n<table>\n<thead>\n<tr>\n<th>对象名称</th>\n<th>对象说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arguments</td>\n<td>函数参数集合</td>\n</tr>\n<tr>\n<td>Array</td>\n<td>数组</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>布尔对象</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>日期对象</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>异常对象</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>函数构造器</td>\n</tr>\n<tr>\n<td>Math</td>\n<td>数学对象</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>数值对象</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>基础对象</td>\n</tr>\n<tr>\n<td>String</td>\n<td>字符串对象</td>\n</tr>\n</tbody>\n</table>\n<h2><code>typeof null</code> 返回结果为 <code>'object'</code></h2>\n<p>  从逻辑上来看，<code>null</code> 值表示一个空对象指针，因此会返回一个 <code>'object'</code>，也可以理解为是 JavaScript 早期的一个BUG，而现在标准就是这样规范的。V8曾经修正并实现过<code>typeof null === 'null'</code>,但最终证明不可行。<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null\">http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null</a></p>\n<h2><code>Array</code> 对象方法与作用</h2>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>对象说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>concat</td>\n<td>用于连接两个或更多的数组并返回结果,<code>arr1.concat(arr2)</code></td>\n</tr>\n<tr>\n<td>join</td>\n<td>把数组的所有元素放入一个字符串，元素通过制定的分隔符进行分离 <code>arr1.join(',')</code></td>\n</tr>\n<tr>\n<td>pop</td>\n<td>删除并返回数组中的最后一个元素 <code>arr1.pop()</code></td>\n</tr>\n<tr>\n<td>push</td>\n<td>向数组的末尾添加一个或更多元素，并返回新的长度 <code>arr1.push(1)</code></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td>颠倒数组中的元素顺序,<code>arr1.reverse()</code></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>删除并返回数组中的第一个元素  <code>arr1.shift()</code></td>\n</tr>\n<tr>\n<td>slice</td>\n<td>从某个已有的数组返回指定的元素</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>对数组的元素进行排序 <code>arr1.sort()</code></td>\n</tr>\n<tr>\n<td>splice</td>\n<td>删除元素，并向数组中添加新元素</td>\n</tr>\n<tr>\n<td>toString</td>\n<td>把数组转成字符串 <code>arr1.toString()</code></td>\n</tr>\n<tr>\n<td>toLocaleString</td>\n<td>把数组转换为本地字符串 <code>arr1.toLocaleString()</code></td>\n</tr>\n<tr>\n<td>valueOf</td>\n<td>返回数组对象的原始值</td>\n</tr>\n</tbody>\n</table>\n<h2><code>typeof</code> 可能的返回值</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>返回结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Undefined</td>\n<td>“undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>“object”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>“boolean”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>“number”</td>\n</tr>\n<tr>\n<td>String</td>\n<td>“string”</td>\n</tr>\n<tr>\n<td>Symbol （ECMAScript 6 新增）</td>\n<td>“symbol”</td>\n</tr>\n<tr>\n<td>宿主对象（由JS环境提供）</td>\n<td>Implementation-dependent</td>\n</tr>\n<tr>\n<td>函数对象（[[Call]] 在ECMA-262条款中实现了）</td>\n<td>“function”</td>\n</tr>\n<tr>\n<td>任何其他对象</td>\n<td>“object”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>上述来自 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\">MDN</a></p>\n</blockquote>\n<p>对文章有不正确之处，请给予纠正。<a href=\"https://github.com/SilenceHVK/articles/issues/16\">github 文章</a> 请顺手给个 Star，最后感谢您的阅读。</p>\n</div>",
        "title": "【JavaScript 基础知识】一篇关于 JavaScript 一些知识点的总结 —— 持续更新",
        "last_reply_at": "2018-11-17T08:57:26.122Z",
        "good": false,
        "top": false,
        "reply_count": 21,
        "visit_count": 3263,
        "create_at": "2018-01-20T03:12:21.593Z",
        "author": {
            "loginname": "SilenceHVK",
            "avatar_url": "https://avatars3.githubusercontent.com/u/12862565?v=4&s=120"
        }
    },
    {
        "id": "5b44291035342ab0690613d6",
        "author_id": "5b37500b5c8f1ea723a56b2b",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>Electron是一个跨平台的桌面应用开发框架，可以让我们用html css js的技术开发跨平台桌面上可以安装的软件。</p>\n<p><strong>前4讲免费试听地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1Dol4tP6Jop6MXro0ULVapQ\">https://pan.baidu.com/s/1Dol4tP6Jop6MXro0ULVapQ</a></p>\n<p>electron Github的 star已经达到61957，那么他的<strong>用户量可能已经有100万了</strong>。还有大家知道的github的atom编辑器、微软的vscode编辑器，包括阿里内部的一些软件也是用 electron 开发的。既然这么热，<strong>那就一个字：学</strong>，大家都在学，你不学（有没有压力啊！！！）</p>\n<p><strong>28元购买地址</strong>:<a href=\"https://www.itying.com/goods-929.html\">https://www.itying.com/goods-929.html</a></p>\n<p><img src=\"//static.cnodejs.org/FqbpQ7iHRMdMdSrEGLD_xpe4CabH\" alt=\"1.png\"></p>\n</div>",
        "title": "Electron视频教程_Electron+Vue跨平台桌面软件开发视频教程（收费啊--不贵一包烟钱-有试听）",
        "last_reply_at": "2018-11-17T03:48:35.403Z",
        "good": false,
        "top": false,
        "reply_count": 28,
        "visit_count": 4809,
        "create_at": "2018-07-10T03:33:36.227Z",
        "author": {
            "loginname": "it-ionic",
            "avatar_url": "https://avatars1.githubusercontent.com/u/17946554?v=4&s=120"
        }
    },
    {
        "id": "5bef8800e6481c5709f5c9f0",
        "author_id": "54ff04a3c1749396754897df",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>某一天用户反馈打开的页面白屏幕，怎么定位到产生错误的原因呢？日常某次发布怎么确定发布会没有引入bug呢？此时捕获到代码运行的bug并上报是多么的重要。</p>\n<p>既然捕获错误并上报是日常开发中不可缺少的一环，那怎么捕获到错误呢？万能的**try…catch**</p>\n<pre class=\"prettyprint language-javascript\"><code>\ntry{\n\nthrow new Error()\n\n} catch(e) {\n\n&#x2F;&#x2F; handle error\n\n}\n</code></pre><p>看上去错误捕获是多么的简单，然而下面的场景下就不能捕获到了</p>\n<pre class=\"prettyprint language-javascript\"><code>\ntry {\n\nsetTimeout(() =&gt; {\n\nthrow new Error(&#x27;error&#x27;)\n\n})\n\n} catch (e) {\n\n&#x2F;&#x2F; handle error\n\n}\n</code></pre><p>你会发现上面的例子中的错误不能正常捕获，看来错误捕获并不是这样简单**try…catch**就能搞定,当然你也可以为异步函数包裹一层**try…catch**来处理。</p>\n<p>浏览器中，**window.onerror**来捕获你的错误</p>\n<pre class=\"prettyprint language-javascript\"><code>\nwindow.onerror = function (msg, url, row, col, error) {\n\nconsole.log(&#x27;error&#x27;);\n\nconsole.log({\n\nmsg, url, row, col, error\n\n})\n\n};\n</code></pre><p>捕获到错误后就可以将错误上报，上报方式很简单，你可以通过创建简单的**img**,通过**src**指定上报的地址，当然为了避免上报发送过多的请求，可以对上报进行合并，合并上报。可以定时将数据进行上报到服务端。</p>\n<p>但但你去看错误上报的信息的时候，你会发现一些这样的错误**Script error**</p>\n<p>因为浏览器的同源策略，对于不同域名的错误，都抛出了**Script error**，怎么解决这个问题呢？特别是现在基本上js资源都会放在cdn上面。</p>\n<p>解决方案</p>\n<p>1：所有的资源都放在同一个域名下。但是这样也会存在问题是不能利用cdn的优势。</p>\n<p>2：增加跨域资源支持，在cdn 上增加支持主域的跨域请求支持，在script 标签加**crossorigin**属性</p>\n<p>在使用<strong>Promise</strong>过程中，如果你没有<strong>catch</strong>,那么可以这样来捕获错误</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&quot;unhandledrejection&quot;, function(err, promise) { \n    &#x2F;&#x2F; handle error here, for example log   \n});\n</code></pre><h3>如何在NodeJs中捕获错误</h3>\n<p>NodeJs中的错误捕获很重要，因为处理不当可能导致服务雪崩而不可用。当然了不仅仅知道如何捕获错误，更应该知道如何避免某些错误。</p>\n<ul>\n<li>\n<p>当你写一个函数的时候，你也许曾经思考过当函数执行的时候出现错误的时候，我是应该直接抛出<strong>throw</strong>，还是使用<strong>callback</strong>或者<strong>event emitter</strong>还是其它方式分发错误呢？</p>\n</li>\n<li>\n<p>我是否应该检查参数是否是正确的类型，是不是<strong>null</strong></p>\n</li>\n<li>\n<p>如果参数不符合的时候，你怎么办呢？抛出错误还是通过<strong>callback</strong>等方式分发错误呢？</p>\n</li>\n<li>\n<p>如果保存足够的错误来复原错误现场呢？</p>\n</li>\n<li>\n<p>如果去捕获一些异常错误呢？<strong>try…catch</strong>还是<strong>domain</strong></p>\n</li>\n</ul>\n<h4>操作错误VS编码错误</h4>\n<h5>1. 操作错误</h5>\n<p>操作错误往往发生在运行时，并非由于代码bug导致，可能是由于你的系统内存用完了或者是由于文件句柄用完了，也可能是没有网络了等等</p>\n<h5>2.编码错误</h5>\n<p>编码错误那就比较容易理解了，可能是<strong>undefined</strong>却当作函数调用，或者返回了不正确的数据类型，或者内存泄露等等</p>\n<h4>处理操作错误</h4>\n<ul>\n<li>\n<p>你可以记录一下错误，然后什么都不做</p>\n</li>\n<li>\n<p>你也可以重试，比如因为链接数据库失败了，但是重试需要限制次数</p>\n</li>\n<li>\n<p>你也可以将错误告诉前端，稍后再试</p>\n</li>\n<li>\n<p>也许你也可以直接处理，比如某个路径不存在，则创建该路径</p>\n</li>\n</ul>\n<h4>处理编码错误</h4>\n<p>错误编码是不好处理的，因为是由于编码错误导致的。好的办法其实重启该进程，因为</p>\n<ul>\n<li>\n<p>你不确定某个编码错误导致的错误会不会影响其它请求，比如建立数据库链接错误由于编码错误导致不能成功，那么其它错误将导致其它的请求也不可用</p>\n</li>\n<li>\n<p>或许在错误抛出之前进行IO操作，导致IO句柄无法关闭，这将长期占有内存，可能导致最后内存耗尽整个服务不可用。</p>\n</li>\n<li>\n<p>上面提到的两点其实都没有解决问题根本，应该在上线前做好测试，并在上线后做好监控，一旦发生类似的错误，就应该监控报警，关注并解决问题</p>\n</li>\n</ul>\n<h4>如何分发错误</h4>\n<ul>\n<li>\n<p>在同步函数中，直接<strong>throw</strong>出错误</p>\n</li>\n<li>\n<p>对于一些异步函数，可以将错误通过<strong>callback</strong>抛出</p>\n</li>\n<li>\n<p><strong>async/await</strong>可以直接使用<strong>try…catch</strong>捕获错误</p>\n</li>\n<li>\n<p><strong>EventEmitter</strong>抛出<strong>error</strong>事件</p>\n</li>\n</ul>\n<h4>NodeJs的运维</h4>\n<p>一个NodeJs运用，仅仅从码层面是很难保证稳定运行的，还要从运维层面去保障。</p>\n<h5>多进程来管理你的应用</h5>\n<p>单进程的nodejs一旦挂了，整个服务也就不可用了，所以我萌需要多个进程来保障服务的可用，某个进程只负责处理其它进程的启动，关闭，重启。保障某个进程挂掉后能够立即重启。</p>\n<p>可以参考<a href=\"https://github.com/Tencent/TSW/blob/master/bin/proxy/master.js\">TSW</a>中多进程的设计。master负责对worker的管理，worker和master保持这心跳监测，一旦失去，就立即重启之。</p>\n<h5>domain</h5>\n<pre class=\"prettyprint language-javascript\"><code>process.on(&#x27;uncaughtException&#x27;, function(err) {\n    console.error(&#x27;Error caught in uncaughtException event:&#x27;, err);\n});\nprocess.on(&#x27;unhandleRejection&#x27;, function(err) {\n  &#x2F;&#x2F; TODO\n})\n</code></pre><p>上面捕获nodejs中异常的时候，可以说是很暴力。但是此时捕获到异常的时候，你已经失去了此时的上下文，这里的上下文可以说是某个请求。假如某个web服务发生了一些异常的时候，还是希望能够返回一些兜底的内容，提升用户使用体验。比如服务端渲染或者同构，即使失败了，也可以返回个静态的html，走降级方案，但是此时的上下文已经丢失了。没有办法了。</p>\n<pre class=\"prettyprint language-javascript\"><code>function domainMiddleware(options) {\n    return async function (ctx, next) {\n        const request = ctx.request;\n        const d = process.domain || domain.create();\n        d.request = request;\n        let errHandler = (err) =&gt; {\n            ctx.set(&#x27;Content-Type&#x27;, &#x27;text&#x2F;html; charset=UTF-8&#x27;);\n            ctx.body = options.staticHtml;\n        };\n        d.on(&#x27;error&#x27;, errHandler);\n        d.add(ctx.request);\n        d.add(ctx.response);\n        try {\n            await next();\n        } catch(e) {\n            errHandler(e)\n        }\n    }\n</code></pre><p>上面是一个简单的koa2的domain的中间件，利用domain监听<strong>error</strong>事件，每个请求的Request, Response对象在发生错误的时候，均会触发<strong>error</strong> 事件，当发生错误的时候，能够在有上下文的基础上，可以走降级方案。</p>\n<h5>如何避免内存泄露</h5>\n<p>内存泄漏很常见，特别是前端去写后端程序，闭包运用不当，循环引用等都会导致内存泄漏。</p>\n<ul>\n<li>\n<p>不要阻塞Event Loop的执行，特别是大循环或者IO同步操作</p>\n<pre class=\"prettyprint language-javascript\"><code>for ( var i = 0; i &lt; 10000000; i++ ) {\n    var user       = {};\n    user.name  = &#x27;outmem&#x27;;\n    user.pass  = &#x27;123456&#x27;;\n    user.email = &#x27;outmem[@outmem](&#x2F;user&#x2F;outmem).com&#x27;;\n}\n</code></pre><p>上面的很长的循环会导致内存泄漏，因为它是一个同步执行的代码，将在进程中执行，V8在循环结束的时候，是没办法回收循环产生的内存的，这会导致内存一直增长。还有可能原因是，这个很长的执行，阻塞了node进入下一个Event loop, 导致队列中堆积了太多等待处理已经准备好的回调，进一步加剧内存的占用。那怎么解决呢？</p>\n<p>可以利用<strong>setTimeout</strong>将操作放在下一个loop中执行，减少长循环，同步IO对进程的阻.阻塞下一个loop 的执行，也会导致应用的性能下降</p>\n</li>\n<li>\n<p>模块的私有变量和方法都会常驻在内存中</p>\n</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>var leakArray = [];   \nexports.leak = function () {  \n  leakArray.push(&quot;leak&quot; + Math.random());  \n};\n</code></pre><p>在node中require一个模块的时候，最后都是形成一个单例，也就是只要调用该函数一下，函数内存就会增长，闭包不会被回收，第二是<strong>leak</strong>方法是一个私有方法，这个方法也会一直存在内存。加入每个请求都会调用一下这个方法，那么内存一会就炸了。</p>\n<p>这样的场景其实很常见</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; main.js\nfunction Main() {\n  this.greeting = &#x27;hello world&#x27;;\n}\nmodule.exports = Main;\n</code></pre><pre class=\"prettyprint language-javascript\"><code>var a = require(&#x27;.&#x2F;main.js&#x27;)();\nvar b = require(&#x27;.&#x2F;main.js&#x27;)();\na.greeting = &#x27;hello a&#x27;;\nconsole.log(a.greeting); &#x2F;&#x2F; hello a\nconsole.log(b.greeting); &#x2F;&#x2F; hello a\n</code></pre><p>require得到是一个单例，在一个服务端中每一个请求执行的时候，操作的都是一个单例，这样每一次执行产生的变量或者属性都会一直挂在这个对象上，无法回收，占用大量内存。</p>\n<p>其实上面可以按照下面的调用方式来调用，每次都产生一个实例，用完回收。</p>\n<pre class=\"prettyprint language-javascript\"><code>var a = new require(&#x27;.&#x2F;main.js&#x27;);\n&#x2F;&#x2F; TODO\n</code></pre><p>有的时候很难避免一些可能产生内存泄漏的问题，可以利用<strong>vm</strong>每次调用都在一个沙箱环境下调用，用完回收调。</p>\n<ul>\n<li>最后就是避免循环引用了，这样也会导致无法回收</li>\n</ul>\n<h2>招纳贤士</h2>\n<p>今日头条长期大量招聘前端工程师，可选北京、深圳、上海、厦门等城市。欢迎投递简历到 <a href=\"mailto:tcscyl@gmail.com\">tcscyl@gmail.com</a> / <a href=\"mailto:yanglei.yl@bytedance.com\">yanglei.yl@bytedance.com</a></p>\n</div>",
        "title": "浅谈前端错误处理",
        "last_reply_at": "2018-11-17T03:16:16.029Z",
        "good": false,
        "top": false,
        "reply_count": 0,
        "visit_count": 213,
        "create_at": "2018-11-17T03:16:16.029Z",
        "author": {
            "loginname": "ixlei",
            "avatar_url": "https://avatars1.githubusercontent.com/u/9430732?v=4&s=120"
        }
    },
    {
        "id": "5beee897be1b120abac5a43a",
        "author_id": "5acf8345464b1bfa6b4250a4",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>项目中遇到一个需求，客户端发起一个http请求后，服务器会调用一个第三方接口做一些耗时5-10秒左右的事情（接口是实时返回的，但并不返回执行接口，只返回命令已经发送，此时我需要等待发送后的结果）。事情处理完成后，会将数据保存入数据库。我需要将这个保存入的数据库中的数据返回给这个http请求。\n我不知道我说的大家是否明白。\n好比我程序发起一个数据库请求的查询，数据库查询完成后会执行回调。这个过程使用nodejs应该怎么来实现呢？\n我想到的办法是制作一个setTimeout，不停的去查询数据库，查询到数据库中的结果后调用回调函数。但总觉得这样的效率太慢。\n请问有遇到过类似问题的同学吗？</p>\n<p>比如如下代码,有办法提高效率吗？\nfunction checkCmd(callback){\n\t  var i=0;\n\t  function check(){\n\t\t  $.post(“<a href=\"http://xxxxx.com/checkCmd\">http://xxxxx.com/checkCmd</a>”,cmd,function(dd){\n\t\t\t  if(dd===1){\n\t\t\t\t callback(dd)\n\t\t\t  }else   if(i&gt;5){\n\t\t\t  \t \tcallback(-1)\n\t\t\t  }else{\n\t\t\t\ti++;\n\t\t\t\tsetTimeout(check,2000);\n\t\t\t  }\n\t\t  })\n\t  }\n\t  check();\n}</p>\n<p>function send(cmd,callback){\n$.post(“<a href=\"http://xxxxx.com/sendCmd\">http://xxxxx.com/sendCmd</a>”,cmd,function(){\nconsole.log(“接口调用成功”);\ncheckCmd(callback);//不停的检查返回结果\n})\n}\nsend({“name”:“abc”},function(b){\n\tconsole.log(b);\n})</p>\n</div>",
        "title": "js中如何做原生的异步等待？或者说如何做一个异步回调？",
        "last_reply_at": "2018-11-17T00:45:08.061Z",
        "good": false,
        "top": false,
        "reply_count": 4,
        "visit_count": 230,
        "create_at": "2018-11-16T15:56:07.583Z",
        "author": {
            "loginname": "pzzcn",
            "avatar_url": "https://avatars1.githubusercontent.com/u/34960683?v=4&s=120"
        }
    },
    {
        "id": "5becfd09be1b120abac5992b",
        "author_id": "53426f0eb5c1556d3801a78c",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>最近因为写项目反复创建 Nest 项目，而默认的生成器生成的项目并不符合我的要求，配置文件、数据库等等功能都没有添加，因此开发了一个脚手架。</p>\n<p><a href=\"https://github.com/coderfox/nestjs-skeleton\">https://github.com/coderfox/nestjs-skeleton</a></p>\n<p>目前还是一个雏形，包括了数据库、日志、环境变量配置、自动格式化等功能。欢迎各位试用和提供意见。</p>\n<p>自带了以下包的集成：</p>\n<ul>\n<li><a href=\"https://nestjs.com\">nest.js</a></li>\n<li><a href=\"https://www.typescriptlang.org\">TypeScript</a></li>\n<li><a href=\"https://typeorm.io\">TypeORM</a> database ORM with PostgreSQL database</li>\n<li><a href>jsonwebtoken</a> json web token</li>\n<li><a href=\"https://github.com/pinojs/pino\">pino</a> logger</li>\n<li><a href=\"https://github.com/af/envalid\">envalid</a> environment configuration loading</li>\n<li><a href=\"https://code.visualstudio.com\">Visual Studio Code</a> integration</li>\n<li><a href=\"https://github.com/typicode/husky\">huksy</a> git hooks</li>\n</ul>\n<p>将来计划添加的功能有：</p>\n<ul>\n<li>unit &amp; integration tests</li>\n<li>Docker support</li>\n<li>controller &amp; service generation</li>\n</ul>\n</div>",
        "title": "Nest.js 脚手架",
        "last_reply_at": "2018-11-16T16:41:07.309Z",
        "good": false,
        "top": false,
        "reply_count": 5,
        "visit_count": 433,
        "create_at": "2018-11-15T04:58:49.725Z",
        "author": {
            "loginname": "coderfox",
            "avatar_url": "https://avatars0.githubusercontent.com/u/3616727?v=4&s=120"
        }
    },
    {
        "id": "5bae03c537a6965f59051d4f",
        "author_id": "5a66101f9d371d4a059eed19",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h3>本着练手为目的开发的项目，不喜勿喷谢谢！</h3>\n<p>项目地址 <a href=\"https://www.cngrok.com\">https://www.cngrok.com</a>\nGithub 地址 <a href=\"https://github.com/ssstk/cngrok\">https://github.com/ssstk/cngrok</a></p>\n<h4>注册本服务并非免费，只需支付一元 即可使用一个月 （这里防止恶意注册）</h4>\n<h2>目前已经实现 ngrok frp 内网穿透管理</h2>\n<h3>主要技术</h3>\n<p>项目主要实现 开源项目ngrok 二次开发, 增加维护隧道列表 验证隧道 简化配置 等等…</p>\n<p>使用nodejs koa2 mongodb 搭建 api 管理</p>\n<p>使用微信扫码免注册登录</p>\n<p>使用vue iview iview-admin 搭建前端管理页面</p>\n<p>使用支付宝 实现收款</p>\n<p>使用websocket 实现用户登录 支付成功 推送通知</p>\n<p>使用aliyun oss+cdn 实现静态资源缓存 客户端下载</p>\n<p>…</p>\n<h3>如果有好的建议或意见 请留言或者提issue 谢谢</h3>\n<p>各位大大 如果可以 希望能给一个Star 给作者一个奖励 谢谢 ～\n源码整理中  后期回放github 中</p>\n</div>",
        "title": "使用nodejs做的 ngrok   frp  内网穿透管理平台",
        "last_reply_at": "2018-11-16T15:01:26.331Z",
        "good": false,
        "top": false,
        "reply_count": 9,
        "visit_count": 1551,
        "create_at": "2018-09-28T10:34:45.022Z",
        "author": {
            "loginname": "wlijie",
            "avatar_url": "https://avatars2.githubusercontent.com/u/14119649?v=4&s=120"
        }
    },
    {
        "id": "5bed5968a05b0e0ae443b9ac",
        "author_id": "5b03c9a7000332b81cf821a5",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>语句如下，其中shop_id建立了索引，扫描行数712127行：\nselect\nid,\nmaterial_id,\ncnt,\nstock_cnt,\nstatus,\ntype,\ngmt_deadline,\nsale_type,\ngmt_gen\nfrom\n<code>stock_count</code> t\nwhere\n<code>t</code>.<code>shop_id</code> = '330547’\nand   <code>t</code>.<code>brand_id</code> = '100148’\nand <code>t</code>.<code>status</code> in (0, 2)\nand <code>t</code>.<code>is_init</code> = 0\nand <code>t</code>.<code>type</code> in (2, 1, 3)\nand <code>t</code>.<code>sale_type</code> in (0, 1)\norder by\n<code>id</code> desc\nLIMIT\n0, 1</p>\n</div>",
        "title": "mysql,一条sql单独执行耗时500ms，批量50条一起执行最慢的耗时5秒",
        "last_reply_at": "2018-11-16T12:21:30.094Z",
        "good": false,
        "top": false,
        "reply_count": 11,
        "visit_count": 431,
        "create_at": "2018-11-15T11:32:56.161Z",
        "author": {
            "loginname": "linxiaoziruo",
            "avatar_url": "https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"
        }
    },
    {
        "id": "5bee84febe1b120abac5a21d",
        "author_id": "5bee83a4be1b120abac5a212",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>安卓手机的优酷缓存了许多的视频，但是每次看视频都要打开优酷，又慢又麻烦，干脆写了这么个小工具</p>\n<p>将手机端的youku/offlinedata下的全部文件夹从手机里拷贝出来，此处假设为拷贝至D:\\youku目录下</p>\n<p>将如下代码保存为combine.js</p>\n<pre class=\"prettyprint language-javascript\"><code>var fs = require(&quot;fs&quot;);\nvar path = require(&quot;path&quot;);\n\n\nfs.readdirSync(&#x27;.&#x2F;&#x27;).forEach((filename) =&gt; {\n\tlet pathname = path.join(&#x27;.&#x27;, filename);\n\tif (fs.statSync(pathname).isDirectory()) {\n\t\t&#x2F;&#x2F;&#x2F; read info file\n\t\tlet infoJsonName = path.join(pathname, &#x27;info&#x27;);\n\t\tlet infoJsonStr = fs.readFileSync(infoJsonName);\n\t\tlet infoJson = JSON.parse(infoJsonStr);\n\t\t\n\t\t&#x2F;&#x2F;&#x2F; create flv file\n\t\tlet flvFileName = path.join(pathname, &#x27;..&#x27;, infoJson.title + &#x27;.flv&#x27;);\n\t\t\n\t\tlet i = 1;\n\t\twhile (fs.existsSync(path.join(pathname, &#x27;&#x27; + i).normalize())) {\n\t\t\tlet filename = path.join(pathname, &#x27;&#x27; + i).normalize();\n\t\t\tlet buffer = fs.readFileSync(filename);\n\t\t\tfs.appendFileSync(flvFileName, buffer);\n\t\t\ti++;\n\t\t}\n\t}\n});\n\n\n执行&#96;node combine.js&#96;即可在父文件夹中生成对应的flv文件，emmmm……这只是我初学node的一点小尝试，期望各路大神多多指教</code></pre></div>",
        "title": "node自动合成手机优酷缓存的小工具",
        "last_reply_at": "2018-11-16T08:59:54.277Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 206,
        "create_at": "2018-11-16T08:51:10.888Z",
        "author": {
            "loginname": "ffpwserver",
            "avatar_url": "https://avatars1.githubusercontent.com/u/6406424?v=4&s=120"
        }
    },
    {
        "id": "5bee3ea1be1b120abac59f0a",
        "author_id": "5595375647e6bdc30297ecad",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fld1xjKag3zEOX0quUeYg1bsyLJ7\" alt=\"test.jpg\"></p>\n<p>没有开启线程</p>\n</div>",
        "title": "请问,定时脚本启动egg框架,出现这个问题的原因是什么",
        "last_reply_at": "2018-11-16T08:40:10.831Z",
        "good": false,
        "top": false,
        "reply_count": 5,
        "visit_count": 220,
        "create_at": "2018-11-16T03:50:57.305Z",
        "author": {
            "loginname": "zhangshiqiu",
            "avatar_url": "https://avatars1.githubusercontent.com/u/8353267?v=4&s=120"
        }
    },
    {
        "id": "545de1e1a68535a174fe51b5",
        "author_id": "52c61c248a716e0b1526d7d2",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>这个链接请求的数据结果乱码，求解决</p>\n<p><a href=\"http://zhuanlan.zhihu.com/api/columns/bigertech/posts/19885746\">http://zhuanlan.zhihu.com/api/columns/bigertech/posts/19885746</a></p>\n<p>在浏览器中打开是正确的，自己使用 <code>request</code> 模块，请求到的数据就是乱码，\n不知道用的什么编码格式编码的 ，\n跪求指导怎么解码？</p>\n<pre class=\"prettyprint\"><code>var request = require(&#x27;request&#x27;);\nrequest(&#x27;http:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;api&#x2F;columns&#x2F;bigertech&#x2F;posts&#x2F;19885746&#x27;, function (req,res,body) {\n    console.log(body);\n});\n</code></pre></div>",
        "title": "request 请求到的数据为乱码，求解决",
        "last_reply_at": "2018-11-16T08:40:00.538Z",
        "good": true,
        "top": false,
        "reply_count": 35,
        "visit_count": 30855,
        "create_at": "2014-11-08T09:26:57.482Z",
        "author": {
            "loginname": "shanelau",
            "avatar_url": "https://avatars2.githubusercontent.com/u/3140898?v=4&s=120"
        }
    },
    {
        "id": "5ab3166be7b166bb7b9eccf7",
        "author_id": "54009f5ccd66f2eb37190485",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><h1>说明</h1>\n<p>2017-12-14 我发了一篇文章《没用过Node.js，就别瞎逼逼》是因为有人在知乎上黑Node.js。那篇文章的反响还是相当不错的，甚至连著名的hax贺老都很认同，下班时读那篇文章，竟然坐车的还坐过站了。大家可以很明显的感到Node.js的普及度还不够，还存很多误解。甚至说很多小白用户也得不到很好的学习。大神都功成身退，书也跟不上，大部分都是2013年左右的，Node.js版本都是基于v0.10左右的，现在已经v9了。想想也是有点可惜，使用如此广泛的Node.js被大家默认，却没人来科普。</p>\n<p>反思之后，我就想准备一个科普的Live，于是就有了《狼叔：如何正确学习 Node.js？》，相信能够对很多喜欢Node.js的朋友有所帮助。Live已完成目前1200多人，230人评价，平均4.8+，还算是一个比较成功的Live。现整理出来，希望对更多朋友有用。</p>\n<ul>\n<li>感谢 <a href=\"/user/justjavac\">@justjavac</a> 大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址，声音版</a></li>\n</ul>\n<h1>【全文】狼叔：如何正确的学习Node.js</h1>\n<p>Live 简介</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容，目录</p>\n<p>Part 0 ：Node.js简介</p>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<p>Part 1前言：学习 Node.js 的三个境界</p>\n<p>Part 2准备：如何学习Node.js</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</p>\n<p>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</p>\n<p>Part 5答疑：回答大家的问题</p>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，希望大家多多理解和支持。</p>\n<h2>Part 0 ：Node.js简介</h2>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<h3>a）Node.js简介</h3>\n<p>Node.js 诞生于 2009 年，由 Joyent 的员工 <a href=\"https://github.com/ry\">Ryan Dahl</a> 开发而成，之后 Joyent 公司一直扮演着 Node.js 孵化者的角色。由于诸多原因，Ryan 在2012年离开社区，随后在2015年由于 Node 贡献者对 es6 新特性集成问题的分歧，导致分裂出iojs，并由 iojs 发布1.0、2.0和3.0版本。由于 iojs 的分裂最终促成了2015年Node基金会的成立，并顺利发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会发展非常好，稳定的发布5、6、7、8等版本，截止发稿最新版本已经是8.6，长期支持版本是6.11。</p>\n<p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p>\n<p>早在2007年，Jeff Atwood 就提出了著名的 <code>Atwood定律</code></p>\n<blockquote>\n<p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</p>\n</blockquote>\n<p>目前 Node.js 在大部分领域都占有一席之地，尤其是 I/O 密集型的，比如 Web 开发，微服务，前端构建等。不少大型网站都是使用 Node.js 作为后台开发语言的，用的最多的就是使用Node.js做前端渲染和架构优化，比如 <a href=\"https://www.taobao.com/\">淘宝</a> 双十一、<a href=\"https://www.qunar.com/\">去哪儿网</a> 的 PC 端核心业务等。另外，有不少知名的前端库也是使用 Node.js 开发的，比如，<a href=\"https://github.com/webpack/webpack\">Webpack</a> 是一个强大的打包器，<a href=\"https://github.com/facebook/react\">React</a>/<a href=\"https://github.com/vuejs/vue\">Vue</a> 是成熟的前端组件化框架。</p>\n<p>Node.js通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和 LinkedIn 都采用了 Node.js 框架搭建应用。</p>\n<p>另外， Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p>\n<p>当然了，Node.js 也有一些缺点。Node.js 经常被人们吐槽的一点就是：回调太多难于控制（俗称回调地狱）和 CPU 密集任务处理的不是很好。但是，目前异步流程技术已经取得了非常不错的进步，从Callback、Promise 到 Async函数，可以轻松的满足所有开发需求。至于 CPU 密集任务处理并非不可解，方案有很多，比如通过系统底层语言 Rust 来扩展 Node.js，但这样会比较麻烦。笔者坚信在合适的场景使用合适的东西，尤其是在微服务架构下，一切都是服务，可以做到语言无关。如果大家想使 JavaScript 做 CPU 密集任务，推荐 Node.js 的兄弟项目 <a href=\"http://fibjs.org/\">fibjs</a>，基于纤程(fiber，可以简单理解为更轻量级的线程)，效率非常高，兼容npm，同时没有异步回调烦恼。</p>\n<h3>b）什么是Node.js？</h3>\n<p>按照 <a href=\"https://nodejs.org/en/\">Node.js官方网站主页</a> 的说法:</p>\n<pre class=\"prettyprint\"><code>Node.js® is a JavaScript runtime built on Chrome&#x27;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I&#x2F;O model that makes it lightweight and efficient. Node.js&#x27; package ecosystem, npm, is the largest ecosystem of open source libraries in the world.\n</code></pre><p>从这段介绍来看，解读要点如下</p>\n<ul>\n<li>Node.js 不是 JavaScript 应用，不是语言（JavaScript 是语言），不是像 Rails(Ruby)、 Laravel(PHP) 或 Django(Python) 一样的框架，也不是像 Nginx 一样的 Web 服务器。Node.js 是 JavaScript 运行时环境</li>\n<li>构建在 Chrome’s V8 这个著名的 JavaScript 引擎之上，Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用，大大的降低了学习成本</li>\n<li>事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model），简单点讲就是每个函数都是异步的，最后由 Libuv 这个 C/C++ 编写的事件循环处理库来处理这些 I/O 操作，隐藏了非阻塞 I/O 的具体细节，简化并发编程模型，让你可以轻松的编写高性能的Web应用，所以它是轻量（lightweight）且高效（efficient）的</li>\n<li>使用 <code>npm</code> 作为包管理器，目前 <code>npm</code> 是开源库里包管理最大的生态，功能强大，截止到2017年12月，模块数量超过 60 万+</li>\n</ul>\n<p>大多数人都认为 Node.js 只能写网站后台或者前端工具，这其实是不全面的，Node.js的目标是让并发编程更简单，主要应用在以网络编程为主的 I/O 密集型应用。它是开源的，跨平台，并且高效（尤其是I/O处理），包括IBM、Microsoft、Yahoo、SAP、PayPal、沃尔玛及GoDaddy都是 Node.js 的用户。</p>\n<h3>c）基本原理</h3>\n<p>下面是一张 Node.js 早期的架构图，来自 Node.js 之父 Ryan Dahl 的演讲稿，在今天依然不过时，它简要的介绍了 Node.js 是基于 Chrome V8引擎构建的，由事件循环（Event Loop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了。</p>\n<p><img src=\"//static.cnodejs.org/Fh2MIT1r4YStGl9ZEEzt7N4lEbqX\" alt=\"14912763353044.png\"></p>\n<p>核心概念</p>\n<ul>\n<li>Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 <code>Chrome</code> 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。</li>\n<li>Event Loop 事件循环（由 <code>libuv</code> 提供）</li>\n<li>Thread Pool 线程池（由 <code>libuv</code> 提供）</li>\n</ul>\n<p>梳理一下</p>\n<ul>\n<li>Chrome V8 是 JavaScript 引擎</li>\n<li>Node.js 内置 Chrome V8 引擎，所以它使用的 JavaScript 语法</li>\n<li>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</li>\n<li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</li>\n<li>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 I/O 很慢，不得不等着结果出来，再往下执行</li>\n<li>CPU 完全可以不管 I/O 设备，挂起处于等待中的任务，先运行排在后面的任务</li>\n<li>将等待中的 I/O 任务放到 Event Loop 里</li>\n<li>由 Event Loop 将 I/O 任务放到线程池里</li>\n<li>只要有资源，就尽力执行</li>\n</ul>\n<p>我们再换一个维度看一下</p>\n<p><img src=\"//static.cnodejs.org/FkTMjCoX4xyL0rJtmm7oBc6V0i8W\" alt=\"14992384974942.png\"></p>\n<p>核心</p>\n<ul>\n<li>Chrome V8 解释并执行 JavaScript 代码（这就是为什么浏览器能执行 JavaScript 原因）</li>\n<li><code>libuv</code> 由事件循环和线程池组成，负责所有 I/O 任务的分发与执行</li>\n</ul>\n<p>在解决并发问题上，异步是最好的解决方案，可以拿排队和叫号机来理解</p>\n<ul>\n<li>排队：在排队的时候，你除了等之外什么都干不了</li>\n<li>叫号机：你要做的是先取号码，等轮到你的时候，系统会通知你，这中间，你可以做任何你想做的事儿</li>\n</ul>\n<p>Node.js 其实就是帮我们构建类似的机制。我们在写代码的时候，实际上就是取号的过程，由 Event Loop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务。之所以说 Node.js 是单线程，就是因为在接受任务的时候是单线程的，它无需进程/线程切换上下文的成本，非常高效，但它在执行具体任务的时候是多线程的。</p>\n<p>Node.js 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”，毫无疑问，它确实做到了。这种做法将并发编程模型简化了，Event Loop和具体线程池等细节被 Node.js 封装了，继而将异步调用 Api 写法暴露给开发者。真是福祸相依，一方面简化了并发编程，另一方面在写法上埋下了祸根，这种做法的好处是能让更多人轻而易举的写出高性能的程序！</p>\n<p>在Node.js Bindings层做的事儿就是将 Chrome V8 等暴露的 <code>C/C++</code> 接口转成JavaScript Api，并且结合这些 Api 编写了 Node.js 标准库，所有这些 Api 统称为 Node.js SDK，后面模块章节会有更详细的讨论。</p>\n<p>微软在2016年宣布在MIT许可协议下开放 Chakra 引擎，并以 <code>ChakraCore</code> 为名在 Github 上开放了源代码，<code>ChakraCore</code> 是一个完整的 JavaScript 虚拟机，它拥有着和 <code>Chakra</code> 几乎相同的功能与特性。微软向 Node.js 主分支提交代码合并请求，让 Node.js 用上 <code>ChakraCore</code>引擎，即 <a href=\"https://github.com/nodejs/node-chakracore\">nodejs/node-chakracore</a> 项目。实际上微软是通过创建名为 <code>V8 shim</code> 的库的赋予了 <code>ChakraCore</code> 处理谷歌 Chrome V8 引擎指令的能力，其原理示意图如下</p>\n<p><img src=\"//static.cnodejs.org/FmJWcazPP4smFeEzBnfnEJuW36ts\" alt=\"15018598977763.jpg\"></p>\n<p>目前，Node.js 同时支持这2种 JavaScript 引擎，二者性能和特性上各有千秋，<code>ChakraCore</code> 在特性上感觉更潮一些，曾经是第一个支持 <code>Async函数</code> 的引擎，但目前 Node.js 还是以 Chrome V8 引擎为主， <code>ChakraCore</code> 版本需要单独安装，大家了解一下就好。</p>\n<h2>Part 1前言：学习 Node.js 的三个境界</h2>\n<p>我总结的编程3种境界</p>\n<ul>\n<li>打日志：console.log</li>\n<li>断点调试：断点调试：node debugger 或node inspector 或vscode</li>\n<li>测试驱动开发（tdd | bdd）</li>\n</ul>\n<p>大家可以自测一下，自己在哪个水平？如果是第三个阶段，那么本场Live可能不太适合你。哈哈哈</p>\n<h2>Part 2准备：如何学习Node.js</h2>\n<p>Node不是语言，不是框架，只是基于V8运行时环境。结合libuv能够通过js语法获得更好的等价于c/c++的性能。</p>\n<p>它很简单，异步是解决并发的最佳实践。本节主要讲如何学习Node.js，是本次Live非常核心的内容，大家要注意听。</p>\n<h3>基础学习</h3>\n<p>1）js语法必须会</p>\n<ol>\n<li>js基本语法，都是c语系的，有其他语言背景学习起来相对更简单</li>\n<li>常见用法，比如正则，比如数据结构，尤其是数组的几种用法。比如bind/call/apply等等</li>\n<li>面向对象写法。js是基于对象的，所以它的oo写起来非常诡异。参见红皮书JavaScript高级编程，很多框架都是自己实现oo基础框架，比如ext-core等。</li>\n</ol>\n<p>犀牛书，《JavaScript权威指南》，没事就多翻翻，看少多少遍都不为过。</p>\n<p>2）个人学习和技术选型都要循序渐进</p>\n<ol>\n<li>先能写，采用面向过程写法，简单理解就是定义一堆function，然后调用，非常简单</li>\n<li>然后再追求更好的写法，可以面向对象。对于规模化的编程来说，oo是有它的优势的，一般java、c#，ruby这些语言里都有面向对象，所以后端更习惯，但对于语言经验不那么强的前端来说算高级技巧。</li>\n<li>等oo玩腻了，可以有更好的追求：函数式编程，无论编程思维，还是用法上都对已有的编程思维是个挑战。我很喜欢函数式，但不太会在团队里使用，毕竟oo阶段还没完全掌握，风险会比较大。但如果团队水平都非常高了，团队稳定是可以用的。</li>\n</ol>\n<p>可以看出我的思路，先能写，然后再追求更好的写法，比如面向对象。等团队水平到一定程度了，并且稳定的时候，可以考虑更加极致的函数式写法。</p>\n<p>团队是这样选型的，个人学习也这样，最好是循序渐进，步子迈大了不好。</p>\n<p>3）各种高级的JavaScript友好语言</p>\n<p>JavaScript友好语言指的是能够使用其他语法实现，但最终编译成js的语言。自从Node.js出现后，这种黑科技层出不穷。比如比较有名的coffee、typescript、babel（es）等。</p>\n<p>CoffeeScript虽然也是JavaScript友好语言，但其语法借鉴ruby，崇尚极简，对于类型和OO机制上还是偏弱，而且这么多年也没发展起来，仍然是比较小众的活着。未来比例会越来越少的。</p>\n<p>显然TypeScript会越来越好，TypeScript 的强大之处是要用过才知道的。</p>\n<ul>\n<li>1）规模化编程，像Java那种，静态类型，面向对象，前端只有TypeScript能做到</li>\n<li>2）亲爹是微软安德斯·海尔斯伯格，不知道此人的请看borland传奇去</li>\n<li>3）开源，未来很好</li>\n<li>4）组合拳：TypeScript + VSCode = 神器</li>\n</ul>\n<p>当下前端发展速度极快，以指数级的曲线增长。以前可能1年都不一定有一项新技术，现在可能每个月都有。大前端，Node全栈，架构演进等等都在快速变化。可以说，前端越复杂，有越多的不确定性，TypeScript的机会就越大。</p>\n<p>4）再论面向对象</p>\n<p>面向对象想用好也不容易的，而且js里有各种实现，真是让人眼花缭乱。</p>\n<ul>\n<li>基于原型的写法，纵观JavaScript高级编程，就是翻来覆去的讲这个，这个很基础，但不好是很好用。可以不用，但不可以不会。</li>\n<li>自己写面向对象机制是最好的，但不是每个人都有这个能力的。好在es6规范出了更好一点的面向对象，通过class、extends、super关键字来定义类，已经明显好很多了，虽然还很弱，但起码勉强能用起来了。从面向过程走过来的同学，推荐这种写法，简单易用。但要注意面向对象要有面向对象的写法，要理解抽象，继承，封装，多态4个基本特征。如果想用好，你甚至还需要看一些设计模式相关的书。好在有《JavaScript设计模式》一书。Koa2里已经在用这种写法了。</li>\n<li>js是脚本语言，解释即可执行。所以它的最大缺点是没有类型系统，这在规模化编程里是非常危险的，一个函数，传参就能玩死人。于是现在流行使用flow和typescript来做类型校验。flow只是工具，比较轻量级。而typescript是es6超级，给es6补充了类型系统和更完善的面向对象机制，所以大部分人都会对ts有好感，很有可能是未来的趋势。</li>\n</ul>\n<p>对于es6高级特性，我是比较保守的，一般node长期支持版本lts支持的我都让用，一些更新的特性我一般不让使用。根本lts版本保持一致就好。</p>\n<p>我的团队现在是采用es6的面向对象写法开发，后面会一点一点转到typescript上的。熟练oo转到ts是非常容易的。</p>\n<h3>安装Node.js环境</h3>\n<p>3m安装法</p>\n<ul>\n<li>nvm（node version manager）【需要使用npm安装，替代品是yrm（支持yarn），nvs对window支持很好】</li>\n<li>nrm（node registry manager）【需要使用npm安装，替代品是yrm（支持yarn）】</li>\n<li>npm（node packages manager）【内置，替代品是n或nvs（对win也支持）】</li>\n</ul>\n<h4>nvm</h4>\n<p>node版本发布非常快，而且多版本共存可能性较大，推荐使用nvm来安装node</p>\n<pre class=\"prettyprint language-shell\"><code>$ curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.6&#x2F;install.sh | bash\n\n$ echo &#x27;export NVM_DIR=&quot;$HOME&#x2F;.nvm&quot;&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ echo &#x27;[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ source ~&#x2F;.zshrc\n\n$ nvm install 0.10\n$ nvm install 4\n$ nvm install 6\n$ nvm install 8\n</code></pre><h4>nrm</h4>\n<p><a href=\"https://registry.npmjs.com\">https://registry.npmjs.com</a> 是node官方的源（registry），服务器在国外，下载速度较慢，推荐安装nrm来切换源，国内的cnpm和taobao的源都非常快，当然，如果你想自建源也是支持的。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global nrm --registry=https:&#x2F;&#x2F;registry.npm.taobao.org\n$ nrm use cnpm\n</code></pre><h4>npm</h4>\n<p>nrm切换完源之后，你安装npm模块的速度会更快。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global yarn\n</code></pre><p>npm基本命令</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>简写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install xxx</td>\n<td>安装xxx模块，但不记录到package.json里</td>\n<td>npm i xxx</td>\n</tr>\n<tr>\n<td>npm install --save xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dependency，是产品环境必须依赖的模块</td>\n<td>npm i -s xxx</td>\n</tr>\n<tr>\n<td>npm install --save-de xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dev-dependency，是开发环境必须依赖的模块，比如测试类的（mocha、chai、sinon、zombie、supertest等）都在</td>\n<td>npm i -D xxx</td>\n</tr>\n<tr>\n<td>npm install --global xxx</td>\n<td>全局安装xxx模块，但不记录到package.json里，如果模块里package.json有bin配置，会自动链接，作为cli命令</td>\n<td>npm i -g xxx</td>\n</tr>\n</tbody>\n</table>\n<h3>常用软件</h3>\n<ul>\n<li>1）oh my zsh是我最习惯的shell，终端下非常好用</li>\n</ul>\n<p>配合iterm2分屏 + spectacle全屏，几乎无敌</p>\n<ul>\n<li>2）brew是mac装软件非常好的方式，和apt-get、rpm等都非常类似</li>\n</ul>\n<p>安装4个必备软件</p>\n<ul>\n<li>\n<p>brew install git 最流行的SCM源码版本控制软件</p>\n</li>\n<li>\n<p>brew install wget 下载、扒站神器</p>\n</li>\n<li>\n<p>brew install ack  搜索代码神器</p>\n</li>\n<li>\n<p>brew install autojump 终端下多目录跳转神器</p>\n</li>\n<li>\n<p>3）vim</p>\n</li>\n</ul>\n<p>我虽然不算vim党，但也深爱着。janus是一个非常好用的vim集成开发环境。比如ctrl-p、nerdtree等插件都集成了，对我这种懒人足够了。</p>\n<h3>IDE和编辑器</h3>\n<p>关于Node.js的IDE和编辑器有很多选择，对比如下</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>是否收费</th>\n<th>断点调试</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Webstorm</td>\n<td>收费</td>\n<td>支持</td>\n<td>是IDE，在代码提示、重构等方面功能非常强大，支持的各种语言、框架、模板也非常多，支持断点调试，好处是特别智能，缺点也是特别智能</td>\n</tr>\n<tr>\n<td>Sublime/TextMate</td>\n<td>收费</td>\n<td>不支持</td>\n<td>编辑器里非常好用的，textmate主要针对mac用户，sublime是跨平台的，相信很多前端开发都熟悉</td>\n</tr>\n<tr>\n<td>Vim/Emace</td>\n<td>免费</td>\n<td>不支持</td>\n<td>命令行下的编辑器，非常强大，难度也稍大，但更为酷炫，而且对于服务器部署开发来说是值得一学的</td>\n</tr>\n<tr>\n<td>VSCode/Atom</td>\n<td>免费</td>\n<td>支持</td>\n<td>Atom比较早，功能强大，缺点稍卡顿，VSCode是微软出的，速度快，对于Node.js 调试，重构，代码提示等方面支持都非常好</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>是一个运行于 Mac、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。它功能强大，便于调试，加上它本身也是基于 Node.js 模块 <code>electron</code> 构建的，尤其要推荐大家使用。</p>\n<p>Visual Studio Code（以下简称vsc）</p>\n<ul>\n<li>vsc是一个比较潮比较新的编辑器（跨平台Mac OS X、Windows和 Linux ）</li>\n<li>vsc功能和textmate、sublime、notepad++，ultraedit等比较，毫不逊色</li>\n<li>vsc尤其是在nodejs（调试）和typescript、go上支持尤其好</li>\n<li>vsc提供了自定义 Debugger Adapter 和 VSCode Debug Protocol 从而实现自己的调试器</li>\n</ul>\n<p>值得一学，我推荐VSCode编辑器！</p>\n<p>更多调试方法，参见https://github.com/i5ting/node-debug-tutorial</p>\n<h3>Node.js应用场景</h3>\n<p>《Node.js in action》一书里说，Node.js 所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为 Node.js 自身在 I/O 上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT 还是范围小了。其实 DIRT 本质上说的 I/O 处理的都算，但随着大前端的发展，Node.js 已经不再只是 I/O 处理相关，而是更加的“Node”！</p>\n<p>Node.js 使用场景主要分为4大类</p>\n<p><img src=\"//static.cnodejs.org/FlXC-FcqbkX4B9ToqUVEy1m-H9Vl\" alt=\"屏幕快照 2017-05-17 07.25.05.png\"></p>\n<ul>\n<li>1）跨平台：覆盖你能想到的面向用户的所有平台，传统的PC Web端，以及PC客户端 <code>nw.js/electron</code> 、移动端 <code>cordova</code>、HTML5、<code>react-native</code>、<code>weex</code>，硬件 <code>ruff.io</code> 等</li>\n<li>2）Web应用开发：网站、Api、RPC服务等</li>\n<li>3）前端：三大框架 React \\ <code>Vue</code> \\ <code>Angular</code> 辅助开发，以及工程化演进过程（使用<code>Gulp</code> /Webpack 构建 Web 开发工具）</li>\n<li>4）工具：<code>npm</code>上各种工具模块，包括各种前端预编译、构建工具 <code>Grunt</code> / <code>Gulp</code>、脚手架，命令行工具，各种奇技淫巧等</li>\n</ul>\n<p>下面列出具体的 Node.js 的使用场景，以模块维度划分</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>描述</th>\n<th>相关模块</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网站</td>\n<td>类似于 <code>cnodejs.org</code> 这样传统的网站</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>Api</td>\n<td>同时提供给移动端，PC，<code>H5</code> 等前端使用的 <code>HTTP Api</code> 接口</td>\n<td><code>Restify</code> / <code>HApi</code></td>\n</tr>\n<tr>\n<td>Api代理</td>\n<td>为前端提供的，主要对后端Api接口进行再处理，以便更多的适应前端开发</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>IM即时聊天</td>\n<td>实时应用，很多是基于 <code>WebSocket</code>协议的</td>\n<td><code>Socket.io</code> / <code>sockjs</code></td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>提供类似于 <code>nginx</code> 反向代理功能，但对前端更友好</td>\n<td><code>anyproxy</code> / <code>node-http-proxy</code> / <code>hiproxy</code></td>\n</tr>\n<tr>\n<td>前端构建工具</td>\n<td>辅助前端开发，尤其是各种预编译，构建相关的工具，能够极大的提高前端开发效率</td>\n<td><code>Grunt</code> / <code>Gulp</code> / <code>Bower</code> / Webpack / <code>Fis3</code> / <code>YKit</code></td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>使用命令行是非常酷的方式，前端开发自定义了很多相关工具，无论是shell命令，node脚本，还是各种脚手架等，几乎每个公司\\小组都会自己的命令行工具集</td>\n<td><code>Cordova</code> / <code>Shell.js</code></td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>有实现，但估计不太会有人用</td>\n<td><code>NodeOS</code></td>\n</tr>\n<tr>\n<td>跨平台打包工具</td>\n<td>使用 Web 开发技术开发PC客户端是目前最流行的方式，会有更多前端开发工具是采用这种方式的</td>\n<td>PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的Cordova，即老的Phonegap，还有更加有名的一站式开发框架Ionicframework</td>\n</tr>\n<tr>\n<td>P2P</td>\n<td>区块链开发、BT客户端</td>\n<td><code>webtorrent</code> / <code>ipfs</code></td>\n</tr>\n<tr>\n<td>编辑器</td>\n<td><code>Atom</code> 和 <code>VSCode</code> 都是基于 <code>electron</code> 模块的</td>\n<td><code>electron</code></td>\n</tr>\n<tr>\n<td>物联网与硬件</td>\n<td>ruff.io和很多硬件都支持node sdk</td>\n<td><code>ruff</code></td>\n</tr>\n</tbody>\n</table>\n<p>Node.js 应用场景非常丰富，比如 Node.js 可以开发操作系统，但一般我都不讲的，就算说了也没多大意义，难道大家真的会用吗？一般，我习惯将 Node.js 应用场景氛围7个部分。</p>\n<p>1）初衷，server端，不想成了前端开发的基础设施\n2）命令行辅助工具，甚至可以是运维\n3）移动端：cordova，pc端：nw.js和electron\n4）组件化，构建，代理\n5）架构，前后端分离、api proxy\n6）性能优化、反爬虫与爬虫</p>\n<ol>\n<li>全栈最便捷之路</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>场景</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的，在后面的http章节里，有单独的讲解。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>爬虫</td>\n<td>有大量的爬虫模块，比如node-crawler等，写起来比python要简单一些，尤其搭配jsdom（node版本的jQuery）类库的，对前端来说尤其友好</td>\n</tr>\n<tr>\n<td>3</td>\n<td>命令行工具</td>\n<td>所有辅助开发，运维，提高效率等等可以用cli做的，使用node来开发都非常合适，是编写命令行工具最简单的方式，java8以后也参考了node的命令行实现</td>\n</tr>\n<tr>\n<td>4</td>\n<td>微服务与RPC</td>\n<td>node里有各种rpc支持，比如node编写的dnode，seneca，也有跨语言支持的grpc，足够应用了</td>\n</tr>\n<tr>\n<td>5</td>\n<td>微信公众号开发</td>\n<td>相关sdk，框架非常多，是快速开发的利器</td>\n</tr>\n<tr>\n<td>6</td>\n<td>前端流行SSR &amp;&amp; PWA</td>\n<td>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</td>\n</tr>\n</tbody>\n</table>\n<p>可以说目前大家能够看到的、用到的软件都有 Node.js 身影，当下最流行的软件写法也大都是基于 Node.js 的，比如 PC 客户端 <a href=\"https://github.com/luin/medis\">luin/medis</a> 采用 <code>electron</code> 打包，写法采用 React + Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js 的应用场景会更加的广泛，更多参见 <a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Node核心：异步流程控制</h3>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js的异步是整个学习Node.js过程中重中之重。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<h4>1) 异步流程控制学习重点</h4>\n<p>我整理了一张图，更直观一些。从09年到现在，8年多的时间里，整个Node.js社区做了大量尝试，其中曲折足足够写一本书的了。大家先简单了解一下。</p>\n<p><img src=\"//static.cnodejs.org/FowNmdNw00ghB3PxKtMz9ajo2i5c\" alt=\"Screen Shot 2017-04-05 at 08.43.08.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p>其实，一般使用是不需要掌握上图中的所有技术的。对于初学者来说，先够用，再去深究细节。所以，精简一下，只了解3个就足够足够用了。</p>\n<p><img src=\"//static.cnodejs.org/Flepwa2gOwCimQX5JbOdL5bK74s1\" alt=\"Screen Shot 2017-04-05 at 08.43.34.png\"></p>\n<p>结论</p>\n<ol>\n<li>Node.js SDK里callback写法必须会的。</li>\n<li>Node.js学习重点: Async函数与Promise\n<ol>\n<li>中流砥柱：Promise</li>\n<li>终极解决方案：Async/Await</li>\n</ol>\n</li>\n</ol>\n<p>所以下面我们会分个小部分进行讲解。</p>\n<h4>2）Api写法：Error-first Callback 和 EventEmitter</h4>\n<p>a）Error-first Callback\n定义错误优先的回调写法只需要注意2条规则即可：</p>\n<ul>\n<li>回调函数的第一个参数返回的error对象，如果error发生了，它会作为第一个err参数返回，如果没有，一般做法是返回null。</li>\n<li>回调函数的第二个参数返回的是任何成功响应的结果数据。如果结果正常，没有error发生，err会被设置为null，并在第二个参数就出返回成功结果数据。</li>\n</ul>\n<p>下面让我们看一下调用函数示例，Node.js 文档里最常采用下面这样的回调方式：</p>\n<pre class=\"prettyprint language-js\"><code>function(err, res) {\n  &#x2F;&#x2F; process the error and result\n}\n</code></pre><p>这里的 <code>callback</code> 指的是带有2个参数的函数：&quot;err&quot;和 “res”。语义上讲，非空的“err”相当于程序异常；而空的“err”相当于可以正常返回结果“res”，无任何异常。</p>\n<p>b）EventEmitter</p>\n<p>事件模块是 Node.js 内置的对观察者模式“发布/订阅”（publish/subscribe）的实现，通过<code>EventEmitter</code>属性，提供了一个构造函数。该构造函数的实例具有 <code>on</code> 方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被 <code>EventEmitter</code> 实例的 <code>on</code> 方法监听到。</p>\n<p>在node 6之后，可以直接使用<code>require('events')</code>类</p>\n<pre class=\"prettyprint language-js\"><code>var EventEmitter = require(&#x27;events&#x27;)\nvar util = require(&#x27;util&#x27;)\n\nvar MyEmitter = function () {\n \n}\n\nutil.inherits(MyEmitter, EventEmitter)\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.on(&#x27;event&#x27;, (a, b) =&gt; {\n  console.log(a, b, this);\n    &#x2F;&#x2F; Prints: a b {}\n});\n\nmyEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;);\n</code></pre><p>和jquery、vue里的Event是非常类似的。而且前端自己也有EventEmitter。</p>\n<p>c）如何更好的查Node.js文档</p>\n<p>API是应用程序接口Application Programming Interface的简称。从Node.js异步原理，我们可以知道，核心在于 Node.js SDK 中API调用，然后交由EventLoop（Libuv）去执行，所以我们一定要熟悉Node.js的API操作。</p>\n<p>Node.js的API都是异步的，同步的函数是奢求，要查API文档，在高并发场景下慎用。</p>\n<p>笔者推荐使用 <a href=\"https://kapeli.com/dash\">Dash</a> 或 <a href=\"https://zealdocs.org/\">Zeal</a> 查看离线文档，经常查看离线文档，对Api理解会深入很多，比IDE辅助要好，可以有效避免离开IDE就不会写代码的窘境。</p>\n<p><img src=\"//static.cnodejs.org/FrIj8UUZLjtGeZDA8RQeBTxff55l\" alt=\"api.png\"></p>\n<h4>3）中流砥柱：Promise</h4>\n<p>回调地狱</p>\n<p>Node.js 因为采用了错误优先的回调风格写法，导致sdk里导出都是回调函数。如果组合调用的话，就会特别痛苦，经常会出现回调里嵌套回调的问题，大家都非常厌烦这种写法，称之为Callback Hell，即回调地狱。一个经典的例子来自著名的Promise模块<a href=\"https://github.com/kriskowal/q\">q</a>文档里。</p>\n<pre class=\"prettyprint language-js\"><code>step1(function (value1) {\n    step2(value1, function(value2) {\n        step3(value2, function(value3) {\n            step4(value3, function(value4) {\n                &#x2F;&#x2F; Do something with value4\n            });\n        });\n    });\n});\n</code></pre><p>这里只是做4步，嵌套了4层回调，如果更多步骤呢？很多新手浅尝辄止，到这儿就望而却步，粉转黑。这明显不够成熟，最起码你要看看它的应对解决方案吧！</p>\n<p>Node.js 约定所有Api都采用错误优先的回调方式，这部分场景都是大家直接调用接口，无太多变化。而Promise是对回调地狱的思考，或者说是改良方案。目前使用非常普遍，可以说是在async函数普及之前唯一一个通用性规范，甚至 Node.js 社区都在考虑 Promise 化，可见其影响之大。</p>\n<p>Promise最早也是在commonjs社区提出来的，当时提出了很多规范。比较接受的是promise/A规范。后来人们在这个基础上，提出了promise/A+规范，也就是实际上现在的业内推行的规范。ES6 也是采用的这种规范。</p>\n<p>Promise意味着[许愿|承诺]一个还没有完成的操作，但在未来会完成的。与Promise最主要的交互方法是通过将函数传入它的then方法从而获取得Promise最终的值或Promise最终最拒绝（reject）的原因。要点有三个：</p>\n<ul>\n<li>递归，每个异步操作返回的都是promise对象</li>\n<li>状态机：三种状态转换，只在promise对象内部可以控制，外部不能改变状态</li>\n<li>全局异常处理</li>\n</ul>\n<p>1)定义</p>\n<pre class=\"prettyprint language-js\"><code>var promise = new Promise(function(resolve, reject) {\n  &#x2F;&#x2F; do a thing, possibly async, then…\n\n  if (&#x2F;* everything turned out fine *&#x2F;) {\n    resolve(&quot;Stuff worked!&quot;);\n  }\n  else {\n    reject(Error(&quot;It broke&quot;));\n  }\n});\n</code></pre><p>每个Promise定义都是一样的，在构造函数里传入一个匿名函数，参数是resolve和reject，分别代表成功和失败时候的处理。</p>\n<p>2)调用</p>\n<pre class=\"prettyprint language-js\"><code>promise.then(function(text){\n    console.log(text)&#x2F;&#x2F; Stuff worked!\n    return Promise.reject(new Error(&#x27;我是故意的&#x27;))\n}).catch(function(err){\n    console.log(err)\n})\n</code></pre><p>它的主要交互方式是通过then函数，如果Promise成功执行resolve了，那么它就会将resolve的值传给最近的then函数，作为它的then函数的参数。如果出错reject，那就交给catch来捕获异常就好了。</p>\n<p>Promise 的最大优势是标准化，各类异步工具库都按照统一规范实现，即使是async函数也可以无缝集成。所以用 Promise 封装 API 通用性强，用起来简单，学习成本低。在async函数普及之前，绝大部分应用都是采用Promise来做异步流程控制的，所以掌握Promise是Node.js学习过程中必须要掌握的重中之重。</p>\n<p>Bluebird是 Node.js 世界里性能最好的Promise/a+规范的实现模块，Api非常齐全，功能强大，是原生Promise外的不二选择。</p>\n<p>好处如下：</p>\n<ul>\n<li>避免Node.js内置Promise实现 问题，使用与所有版本兼容</li>\n<li>避免Node.js 4曾经出现的内存泄露问题</li>\n<li>内置更多扩展，timeout、 promisifyAll等，对Promise/A+规范提供了强有力的补充</li>\n</ul>\n<p>限于时间关系，这里就不一一列举了，还是那句话，在学习Node.js过程中，对于Promise了解多深入都不过分。</p>\n<p>推荐学习资料</p>\n<ul>\n<li>Node.js最新技术栈之Promise篇  <a href=\"https://cnodejs.org/topic/560dbc826a1ed28204a1e7de\">https://cnodejs.org/topic/560dbc826a1ed28204a1e7de</a></li>\n<li>理解 Promise 的工作原理 <a href=\"https://cnodejs.org/topic/569c8226adf526da2aeb23fd\">https://cnodejs.org/topic/569c8226adf526da2aeb23fd</a></li>\n<li>Promise 迷你书 <a href=\"http://liubin.github.io/promises-book/\">http://liubin.github.io/promises-book/</a></li>\n</ul>\n<h4>4）终极解决方案：Async/Await</h4>\n<p>Async/Await是异步操作的终极解决方案，Koa 2在node 7.6发布之后，立马发布了正式版本，并且推荐使用async函数来编写Koa中间件。</p>\n<p>这里给出一段Koa 2应用里的一段代码</p>\n<pre class=\"prettyprint\"><code>exports.list = async (ctx, next) =&gt; {\n  try {\n    let students = await Student.getAllAsync();\n  \n    await ctx.render(&#x27;students&#x2F;index&#x27;, {\n      students : students\n    })\n  } catch (err) {\n    return ctx.api_error(err);\n  }\n};\n</code></pre><p>它做了3件事儿</p>\n<ul>\n<li>通过await Student.getAllAsync();来获取所有的students信息。</li>\n<li>通过await ctx.render渲染页面</li>\n<li>由于是同步代码，使用try/catch做的异常处理</li>\n</ul>\n<p>是不是非常简单，现在Eggjs里也都是这样同步的代码。</p>\n<p>4.1 正常写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\nasync function main(){\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n}\n\nmain();\n</code></pre><p>变态写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\n(async () =&gt; {\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n})();\n</code></pre><p>4.2 await + Promise</p>\n<pre class=\"prettyprint\"><code>const Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n    const contents = await fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n    console.log(contents);\n}\n\nmain();\n</code></pre><p>4.3 await + co + generator</p>\n<pre class=\"prettyprint\"><code>const co = require(&#x27;co&#x27;);\nconst Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n   const contents = co(function* () {\n      var result = yield fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n      return result;\n   })\n\n\tconsole.log(contents);\n}\n\nmain();\n</code></pre><p>要点</p>\n<ul>\n<li>co的返回值是promise，所以await可以直接接co。</li>\n<li>co的参数是genrator</li>\n<li>在generator里可以使用yield，而yield后面接的有5种可能，故而把这些可以yield接的方式成为yieldable，即可以yield接的。\n<ul>\n<li>Promises</li>\n<li>Thunks (functions)</li>\n<li>array (parallel execution)</li>\n<li>objects (parallel execution)</li>\n<li>Generators 和 GeneratorFunctions</li>\n</ul>\n</li>\n</ul>\n<p>由上面3中基本用法可以推出Async函数要点如下：</p>\n<ul>\n<li>Async函数语义上非常好</li>\n<li>Async不需要执行器，它本身具备执行能力，不像Generator需要co模块</li>\n<li>Async函数的异常处理采用try/catch和Promise的错误处理，非常强大</li>\n<li>Await接Promise，Promise自身就足够应对所有流程了，包括async函数没有纯并行处理机制，也可以采用Promise里的all和race来补齐</li>\n<li>Await释放Promise的组合能力，外加co和Promise的then，几乎没有不支持的场景</li>\n</ul>\n<p>综上所述</p>\n<ul>\n<li>Async函数是趋势，如果Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>小结</p>\n<p>这部分共讲了4个小点，都是极其直接的必须掌握的知识点。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<p>这里再提一下关于Node.js源码阅读问题，很多人api都还没完熟练就去阅读源码，这是非常不赞成的，不带着问题去读源码是比较容易迷失在大量代码中的。效果并不好。</p>\n<p>先用明白，然后再去阅读Node.js源码，然后探寻libuv并发机制。很多人买了朴大的《深入浅出Node.js》一书，看了之后还是不太会用，不是书写的不好，而是步骤不对。</p>\n<ul>\n<li>Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了</li>\n<li>当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。</li>\n<li>实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</li>\n</ul>\n<p>我一般给大家的推荐是把Node in action读上5遍10遍，入门干活足够了。剩下的就是反复实践，多写代码和npm模块就好。</p>\n<p>目前所有的书籍几乎都有点过时了，大部分都是Node.js v0.10左右的版本的，我得新书是基于Node.js 8版本的，预计2018年3月或4月出版。别催我，真没法更快了。</p>\n<p>目录</p>\n<ul>\n<li><a href>01 Node.js初识</a></li>\n<li><a href>02 安装与入门</a></li>\n<li><a href>03 更了不起的Node.js</a></li>\n<li><a href>04 更好的Node.js</a></li>\n<li><a href>05 Node.js是如何执行的</a></li>\n<li><a href>06 模块与核心</a></li>\n<li><a href>07 异步写法与流程控制</a></li>\n<li><a href>08 下一代Web框架Koa入门</a></li>\n<li><a href>09 Koa的核心扩展机制：中间件</a></li>\n<li><a href>10 HTTP协议必知必会</a></li>\n<li><a href>11 Koa练习</a></li>\n<li><a href>12 数据库入门</a></li>\n<li><a href>13 数据库进阶</a></li>\n<li><a href>14 视图模板</a></li>\n<li><a href>15 Koa项目实战</a></li>\n<li><a href>16 自己动手写NPM模块</a></li>\n<li><a href>17 Node.js企业级Web开发</a></li>\n<li><a href>18 构建具有Node.js特色的微服务</a></li>\n<li><a href>19 让Node.js跑的更稳</a></li>\n<li><a href>20 让Node.js跑的更快</a></li>\n</ul>\n<p>博文视点的美女编辑在苦逼的整理中，预计出版在3月之后（不要催我，我也没法说），20章，800页+，定价预计在130+。</p>\n<h3>Web编程要点</h3>\n<p>一般，后端开发指的是 Web 应用开发中和视图渲染无关的部分，主要是和数据库交互为主的重业务型逻辑处理。但现在架构升级后，Node.js 承担了前后端分离重任之后，有了更多玩法。从带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，到通过 RPC 调用封装对数据库的操作，到提供前端 Api 代理和网关，服务组装等，统称为<strong>后端开发</strong>，不再是以往只有和数据库打交道的部分才算后端。这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。</p>\n<p>对 Node.js 来说，一直没有在后端取得其合理的占有率，原因是多方面的，暂列几条。</p>\n<ul>\n<li>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。</li>\n<li>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。</li>\n<li>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</li>\n<li>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。</li>\n</ul>\n<p>尽管如此，Node.js 还是尽人皆知，卷入各种是非风口，也算是在大前端浪潮中大红大紫。原因它的定位非常明确，补足以 JavaScript 为核心的全栈体系中服务器部分。开发也是人，能够同时掌握并精通多门语言的人毕竟不多，而且程序员的美德是“懒”，能使用 JavaScript 一门语言完成所有事儿，为什么要学更多呢？</p>\n<p>对于 Web 应用大致分2种，带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，我们先看一下 Node.js Web 应用开发框架的演进时间线大致如下：</p>\n<ul>\n<li>2010年 TJ Holowaychuk 写的 Express</li>\n<li>2011年 Derby.js 开始开发，8月5日，WalmartLabs 的一位成员 Eran Hammer 提交了 Hapi 的第一次git记录。Hapi 原本是 Postmile 的一部分，并且最开始是基于 Express 构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于 Rest api 的 Restify 发布1.0版本，同构的 Meteor 开始投入开发，最像Rails 的 Sails 也开始了开发</li>\n<li>2013年 TJ Holowaychuk 开始玩 es6 generator，编写 <code>co</code> 这个 Generator 执行器，并开始了Koa 项目。2013 年下半年李成银开始 ThinkJS，参考 ThinkPHP</li>\n<li>2014年4月9日，Express 发布4.0，进入4.x时代持续到今天，MEAN.js 开始随着 MEAN 架构的提出开始开发，意图大一统，另外 Total.js 开始起步，最像PHP里 Laravel 或 Python 里的 Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架，代表着 Node.js 的成熟，开始从其他语言里的成熟框架借鉴</li>\n<li>2015年8月22日，下一代 Web 框架 Koa 发布1.0，可以在Node.js v0.12下面，通过<code>co</code> 和 generator实现同步逻辑，那时候 <code>co</code> 还是基于 <code>thunkfy</code> 的，在2015年10月30日，ThinkJS发布了首个基于 Es2015+ 特性开发的 v2.0 版本</li>\n<li>2016 年 09 月，蚂蚁金服的 Eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架 Koa 发布v2.0正式版</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n<tr>\n<td>Egg</td>\n<td>基于Koa，在开发上有极大便利</td>\n<td>企业级Web开发框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能够做到源码级定制。Node.js 已经有8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>Tips：个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>Node.js 本来就为了做后端而设计的，这里我们再看看利益问题。Node.js 向后端延伸，必然会触动后端开发的利益。那么 Proxy 层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是 Node.js 能不能做这部分呢？答案是能的，这个是和 Java、PHP 类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以 Java、PHP 等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于 Node.js ，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用 Node.js 开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以 Node.js 在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对 Node.js 的误解。</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于 <code>MongoDB</code>、<code>MySQL</code>、<code>Redis</code> 等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题是个伪命题，所有框架面临的都是一样的。</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了，本书后面有大量篇幅讲如何使用 Koa 框架来构建Api服务。</p>\n<p>Web编程核心</p>\n<ul>\n<li>异步流程控制（前面讲过了）</li>\n<li>基本框架 Koa或Express，新手推荐Express，毕竟资料多，上手更容易。如果有一定经验，推荐Koa，其实这些都是为了了解Web编程原理，尤其是中间件机制理解。</li>\n<li>数据库 mongodb或mysql都行，mongoose和Sequelize、bookshelf，TypeOrm等都非常不错。对于事物，不是Node.js的锅，是你选的数据库的问题。另外一些偏门，想node连sqlserver等估计还不成熟，我是不会这样用的。</li>\n<li>模板引擎， ejs，jade，nunjucks。理解原理最好。尤其是extend，include等高级用法，理解布局，复用的好处。其实前后端思路都是一样的。</li>\n</ul>\n<h3>迷茫时学习Node.js最好的方法</h3>\n<p>Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。现在早已经超过60万个模块了。</p>\n<p>这里就不一一举例了，给出一个<strong>迷茫时学习Node.js最好的方法</strong>吧！</p>\n<p>某天，我在3w咖啡整理书稿，然后小弟梁过来了，聊聊他的现状，一副很不好的样子，在天津我曾带过他大半年，总不能不管，我给他的建议是：“每天看10个npm模块”</p>\n<p>对于学习Node.js迷茫的人来说，这是最好的方式，当你不知道如何做的时候，就要向前（钱）看，你要知道积累哪些技能对以后有好处。对于学习Node.js必经之路，一定是要掌握很多模块用法，并从中汲取技巧、思路、设计思想的。与其不知道学什么，为什么不每天积累几个技巧呢？</p>\n<p>推荐一个repo即 <a href=\"https://github.com/parro-it/awesome-micro-npm-packages\">https://github.com/parro-it/awesome-micro-npm-packages</a> 小型库集合，一天看十个不是梦！</p>\n<p>更多讨论 <a href=\"https://zhuanlan.zhihu.com/p/29625882\">https://zhuanlan.zhihu.com/p/29625882</a></p>\n<h3>非科班出身如何Node.js</h3>\n<p>有朋友提问</p>\n<pre class=\"prettyprint\"><code>狼叔，关注你和cnode很久了，最近有点迷茫，想请你指点下。\n我的情况是这样的，非科班出身，从事前端工作4年，公司使用的技术栈是vue2、vue-router、vuex、webpack，目前的能力处理工作还是比较轻松，但是也很明确自己有很多不足，只是对于如何提升比较迷茫。\n不足：\n1、非科班出身，计算机基础薄弱\n2、对当前使用的技术了解不够深入，很多东西只停留在会用的层面\n3、对服务端了解较少，想学node，却不知道如何系统的学习\n</code></pre><p>解答困惑：</p>\n<p>1、计算机基础薄弱该如何完善自己的知识体系？</p>\n<p>答:追逐长尾，所见所闻不懂的都去学就好啦。我是这样过来的，头几年每天14个小时+，很累，不过效果还可以。os，算法，数据结构，设计模式，编译原理，基本也就这些重点。做到每天都有进步就好，别贪多求快。数学和英文当然也是越狠越好的！</p>\n<p>2、如何在技术上做更深入的探索？</p>\n<p>答:技术人只关注技术，想法创意通常比较少。最简单的办法就是抓自己的痒，比我大学时和朋友们翻译过grails文档，所以对翻译有情节。为了翻译，我用node写了无数工具尝试，反复对比各种翻译工具，理解它们背后的设计。包括markdown里嵌html标签标识中英文，然后gulp编译成独立文档。甚至一度想上线卖服务。这种折腾真的很爽，甚至耽误了不少翻译。有时要警惕长尾，不要忘了自己的初衷</p>\n<p>3、如何系统的学习node？</p>\n<p>答:阶段</p>\n<p>1/要会用，能完成工作任务\n2/写点提高效率的工具\n3/参与开源项目，甚至是node源码</p>\n<p>应对方法</p>\n<p>1/《node in action》看五遍，然后就去写吧，别管代码质量如何，能写敢写\n2/多用些模块，理解它们，如果有机会就自己写一下，万一有很多人用你，我小弟写过一个地区选择加载的json数据，star数不少呢\n3/给别人贡献代码，要去学别人的习惯，网上有git标准工作流和提pr方法，你要做的是精研该模块代码，关注issue，其他就是等机会。另外朴灵的深入浅出多读几遍，试着读node源码，你的理解会更好。推荐看看我写的《通过开源项目去学习》<a href=\"https://github.com/i5ting/Study-For-StuQ\">https://github.com/i5ting/Study-For-StuQ</a>\n4/跳出node范围，重新审视node的应用场景，对未来你的技术选项和决策大有裨益</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n</ul>\n<p>答：如果有机会就直接上Web应用，如果没有机会就从前端构建，工具等方面开始做，慢慢引入更潮更酷的前端技术，自然就把Node引入进来了。不要急。</p>\n<ul>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n</ul>\n<p>答：初学者推荐Express，如果有一定经验，推荐Koa。当然真正项目里还是推荐Eggjs和Thinkjs这样的框架。</p>\n<ul>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>答：\n1）Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了\n2）当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。\n3)实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</p>\n<p>如果你不着急，也可以等我的那本《更了不起的Node.js》，时间待定。</p>\n<h2>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</h2>\n<p>有朋友问现在Android开发和web前端开发哪个前景更好？我的回答是明显是前端更好，看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。</p>\n<p>Web开发对移动端的冲击非常大。当然现在Web技术也开发PC client了，比如vscode是通过electron打包的，效果还是相当不错的。</p>\n<p>前端可以说是最近几年开发里最火的部分，原因很多，最主要是开发方式的变更，以今时今日的眼光来看，称之为现代Web开发是不为过的。</p>\n<p>先给出现代Web开发的概览图</p>\n<p><img src=\"//static.cnodejs.org/Fq7XArZKEXlzHEwBiR35IxHs4nOg\" alt=\"15117552681353.jpg\"></p>\n<p>每次演讲我会都问大家是不是前端，回答“是”的人非常多，我会开玩笑的恭喜大家：“现在的前端就是钱端”，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。</p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。</p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，这也是我那本书书名字里“更了不起的”要去阐述的内容。</p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈</code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。</p>\n<p>全栈核心</p>\n<ul>\n<li>后端不会的 UI（界面相关）</li>\n<li>前端不会的 DB（业务相关）</li>\n</ul>\n<p>只要打通这2个要点，其他就比较容易了。最怕的是哪样都接触点，然后就号称自己是全栈，建议大家不要这样做，这就好比在简历里写精通一样，基本上都会被问到尴尬。全栈是一种信仰，不是拿来吹牛逼的，而可以解决更多问题，让自己的知识体系不留空白，享受自我实现的极致快乐。</p>\n<h3>我的全栈之路</h3>\n<p>想问一下狼叔最近的业务一直都是简单的用express搭一个后端服务，没有其他更加深入node的业务了，这种时候应该如何自己给自己创应用场景呢</p>\n<blockquote>\n<p>没有目标就向钱看，有目标就向前看</p>\n</blockquote>\n<ul>\n<li>从 java 开始，蹭课，背着机箱到深圳，3个月胖20斤</li>\n<li>坚持翻译英文文档，看 《Thinking in Java》</li>\n<li>毕业后开始 bi，整理 bi 文档</li>\n<li>学长明林清，传授 jQuery，愿意学，别人就更愿意分析</li>\n<li>接手《内蒙广电数据分析与科学决策系统》，打通前、后端</li>\n<li>广东联通，自己造轮子，写 jQuery 插件，DRY</li>\n<li>做云计算，学习 AIX，写有《凌云志》</li>\n<li>分手、离职，去做 iOS，从 cordova 开始搞 H5，研究各种移动端框架，自己写框架，转原生</li>\n<li>面试也是学习的利器，轻松进新浪</li>\n<li>总结了大量 iOS 经验，想写书，结果写了一堆写书的工具</li>\n</ul>\n<blockquote>\n<p>既然无法逃避，就热爱它，最后变成兴趣</p>\n</blockquote>\n<ul>\n<li>去网秦做技术总监，做首席，管架构，带人，写开源项目</li>\n<li>创业，当 CTO，结婚，做公众号运营，写书，最苦的时候没钱吃饭，又不能找媳妇要，只能在 StuQ 上讲点课</li>\n<li>加入去哪儿网，任职前端架构师</li>\n<li>加入阿里巴巴，前端技术专家</li>\n</ul>\n<blockquote>\n<p>人生不只有代码，但它能让我快乐，终生受益</p>\n</blockquote>\n<p>也曾懵懂，也曾迷茫，但我这人比较傻，一直信奉：“一次只做1件事儿，尽力做到极致”，短时间看这是比较傻的，但一旦你坚持下去，你就会发现技术其实是门手艺，厚积薄发。</p>\n<p>我没办法说自己最擅长什么，但在什么场景下用什么技术是我擅长的。或者说，应变是我最大的本事。很多框架，新技术我都没见过，用过，但花一点点过一下，就能拿已有的知识快速的理解它，这其实是长期学习的好处。</p>\n<p>现在越来越忙，写代码的时间越来越少，技术又越发展越快，我能做好的就是每日精进，仗着这点已有的知识储备跟年轻人比赛。我不觉得累，相反我很享受这种感觉，没有被时代淘汰，是一件多么幸福的事儿。</p>\n<h3>从后端转</h3>\n<p>做后端的人</p>\n<ul>\n<li>对数据库是比较熟悉，无论 mongodb，还是 mysql、postgres</li>\n<li>对前端理解比较弱，会基本的 html，css，模板引擎等比较熟悉</li>\n</ul>\n<blockquote>\n<p>4阶段循序渐进，build 与工具齐飞</p>\n</blockquote>\n<p>前端开发4阶段，我的感觉是按照顺序，循序渐进就好。</p>\n<h3>从前端转</h3>\n<p>从前端往后端转，api 接口非常容易学会，像 express、koa 这类框架大部分人一周就能学会，最难的是对 db、er 模型的理解，说直白点，还是业务需求落地的理解</p>\n<p>我们来想想一般的前端有什么技能？</p>\n<ul>\n<li>html</li>\n<li>css（兼容浏览器）</li>\n<li>js 会点（可能更多的是会点 jquery）</li>\n<li>ps 切图</li>\n<li>firebug 和 chrome debuger 会的人都不太多</li>\n<li>用过几个框架，大部分人是仅仅会用</li>\n<li>英语一般</li>\n<li>svn/git 会一点</li>\n</ul>\n<p>那么他们如果想在前端领域做的更深有哪些难点呢？</p>\n<ul>\n<li>基础：oo，dp，命令，shell，构建等</li>\n<li>编程思想上的理解（mvc、ioc，规约等）</li>\n<li>区分概念</li>\n<li>外围验收，如 H5 和 hybird 等</li>\n<li>追赶趋势，如何学习新东西</li>\n</ul>\n<p>以上皆是痛点，所以比较好的办法应该是这样的。</p>\n<ul>\n<li>玩转 npm、gulp 这样的前端工具类（此时还是前端）</li>\n<li>使用 node 做前后端分离（此时还是前端）</li>\n<li>express、koa 这类框架</li>\n<li>jade、ejs 等模板引擎</li>\n<li>nginx</li>\n<li>玩转【后端】异步流程处理（promise/es6的(generator|yield)/es7(async|await)）</li>\n<li>玩转【后端】mongodb、mysql 对应的 Node 模块</li>\n</ul>\n<p>从我们的经验看，这样是比较靠谱的。先做最简单前后端分离，里面没有任何和db相关，前端可以非常容易的学会，基本2周就已经非常熟练了。一般半年后，让他们接触【异步流程处理】和【数据库】相关内容，学习后端代码，就可以全栈了。</p>\n<h3>从移动端转</h3>\n<p>看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。狼叔一直固执的以为未来是h5的。</p>\n<p>现在的 Native 开发是姥姥不疼舅舅不爱，非常尴尬，很明显连培训出的人就业不要工资混经验就很明显了。另外领导们也都在惦记，能不能用 H5 写？这还算是保守的，如果直接激进的就直接上 RN 了，那么 Native开发的程序员就变了</p>\n<blockquote>\n<p>一个写插件的程序员…招谁惹谁了。。。。</p>\n</blockquote>\n<p>要么忍，要么转，没办法，认命吧，温水里舒服了几年，也该学点东西了</p>\n<ul>\n<li>hybrid 或组件化开发，你总要会一样</li>\n<li>无论哪种，你都离前端很近，因为 H5 或组件化都是从前端走出来的</li>\n<li>组件化在前端领域先行，无论借鉴还是学习都不可避免</li>\n<li>如果没时间就直接上组件化，如果有时间就好好学学前端完整体系，最终也还是要学组件化</li>\n</ul>\n<p>原生开发就是 iOS 用 OC/Swift,Android 用 java 或 scala 等，就算偶尔嵌入 webview，能玩js的机会也非常好少</p>\n<p>所以移动端转全栈的方法，最好是从 cordova（以前叫 phonegap）开始做 hybrid 开发。</p>\n<ul>\n<li>只要关注 www 目录里的 H5 即可，比较简单</li>\n<li>如果 H5 不足以完成的情况下，可以编写 cordova 插件，即通过插件让 js 调用原生 sdk 里功能</li>\n<li>cordova 的 cli 可以通过 npm 安装，学习 npm 的好方法</li>\n<li>学习 gulp 构建工具</li>\n</ul>\n<p>只要入了 H5 的坑，其实就非常好办了。</p>\n<ul>\n<li>然后 h5、zeptojs、iscroll、fastclick 等</li>\n<li>然后微信常用的，如 weui、vux（vue+weui）、jmui（react+weui）</li>\n<li>然后可以玩点框架，比如 jquery mobile，sencha touch</li>\n<li>然后可以玩点高级货，ionicframework（基于 angularjs、cordova）</li>\n<li>然后前端4阶段，依次打怪升级</li>\n<li>然后 node</li>\n</ul>\n<p>这个基本上是我走的路，从2010年写iOS、做phonegap（当时是0.9.3）、一路走到现在的总结吧！</p>\n<p>以前技术发展还不是那么明显，写 Java 的时候 <code>Apache</code> 的开源用的比较多，那时开源的代码托管<code>sourceforge</code>，<code>google code</code> 也都凑合用，自从 <code>Git</code> 和 <code>GitHub</code> 出现时候，代码社交兴起，极大的促进了开源的活跃，使得大量明星项目脱引而出。这是好事，如果没有开源，中国的软件水平真是要落后好多年。那么问题也来了，如何能够在技术快速发展的今天，个人成长也能更好呢？</p>\n<p>学习的3种层次，跟人学最快，其次是跟书（或者博客）学，最差的是自悟。但是牛人不能遇到，遇到了也未必有精力教你，书本或者博客，别人有，但不一定写出来，就算是写了，可能只是点到为止。至于自悟，如果没有深厚的积累的，还是有相当大难度的。</p>\n<p>对于开发来说代码是一切基础，在掌握了一定计算机基础后，其差别就在于代码质量和眼界。编程没有捷径，能够做到每日精进就是极好的。现在开源代码非常多，要能够从中获取自己所需的知识，也是一种本领！如果能够坚持着每日精进，根本不需要向其他人学习的。</p>\n<p><img src=\"//static.cnodejs.org/FvXJwylBhEv33TowEJYMfX-CULZC\" alt=\"15011322589471.jpg\"></p>\n<p>大家可以在 Github 随便打开一个前端项目，里面有一半以上都是 Node.js 相关信息，各种包管理、测试、ci、辅助模块，如果大家对这些基础信息掌握的非常好，那么学习一个新的框架，你要比别人快好多，最重要的是学了一次，到处使用。</p>\n<p>很多人问我怎么才能成为一个 Node.js 大神？我的回答是“在cnode论坛上坚持写文章和开源项目2年，足矣，轻松进阿里腾讯，不用你找他们，他们自会找你的”。</p>\n<blockquote>\n<p>从今天起，开始重视开源项目，重视 node，做到每日精进</p>\n</blockquote>\n<h2>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</h2>\n<h3>招人标准</h3>\n<p>先说下我的招人标准，做技术总监时上指下派只要看好技术能力和态度即可，做CTO时要考虑团队文化，人品和能否在公司长留，所以不同的人面试要看的点是不一样的，我曾面过很多Node.js程序员，也见过很多面试题，汇总一下，大致有以下9个点：</p>\n<ol>\n<li>基本的Node.js几个特性，比如事件驱动、非阻塞I/O、Stream等</li>\n<li>异步流程控制相关，Promise是必问的</li>\n<li>掌握1种以上Web框架，比如Express、Koa、Thinkjs、Restfy、Hapi等，会问遇到过哪些问题、以及前端优化等常识</li>\n<li>数据库相关，尤其是SQL、缓存、Mongodb等</li>\n<li>对于常见Node.js模块、工具的使用，观察一个人是否爱学习、折腾</li>\n<li>是否熟悉linux，是否独立部署过服务器，有+分</li>\n<li>js语法和es6、es7，延伸CoffeeScript、TypeScript等，看看你是否关注新技术，有+分</li>\n<li>对前端是否了解，有+分</li>\n<li>是否参与过或写过开源项目，技术博客、有+分</li>\n</ol>\n<p>补充一句:只看技能没人品的人，千万别招，白脸狼</p>\n<p>主动执行，辅助团队\n掌握一门后端语言；熟悉用户体验相关知识；了解软件工程。\n精通浏览器工作原理，熟悉HTTP协议，熟悉设计模式。\n掌握改善无障碍访问的方法；掌握数据采集分析能力；熟悉可维护性问题。\n通过开发、使用、推广效率工具让自己与团队的效率得到提高；\n提炼可复用组件，为类库贡献高质量代码.\n积极完善知识库；\n跨团队分享技术和专业相关知识。\n辅导新人技能成长；\n协助主管做招聘和团队管理工作。</p>\n<h3>大家是选大公司还是小公司？</h3>\n<p>我再知乎上回复的《在跳槽后的第三个月，收到世界500强的offer，我该怎么办？》</p>\n<p>1）互联网公司优先，流量大，人才多，机会也多，流程规范一些</p>\n<p>2）今天的世界500强不比从前了，普华永道应该是四大之一，不知道信息化怎么样，你只要和你现在的公司对比就好了。</p>\n<p>3）问问自己想要什么，钱，经历，还是时间</p>\n<p>如果你很年轻，现在很安逸，我建议你换。如果不是很想动，那就学会所有能接触到的知识再换。</p>\n<p>我是降薪来的阿里，原因有三，一是有事可为，老板重用你给你机会，二是集团内部是open的，偏偏我知识面足够可以看出它们的好处，算是另一种补偿吧，三是对个人品牌是一个升级，狼叔的职业生涯到此已经足够了，进可攻退可守，也算另一种自由吧！</p>\n<p>钱多是个优势而已，还有氛围，文化，信仰</p>\n<ul>\n<li>牛人多</li>\n<li>业务需要</li>\n<li>成熟后有更多精力</li>\n<li>内部竞争，优胜劣汰</li>\n<li>财务相对自由，可以追求信仰了</li>\n</ul>\n<p>前几天还和 @苏千 聊，我和 @死月絲卡蕾特 相继入职阿里，还有cnode社区著名程序员也即将入职阿里，当时大家开玩笑说:</p>\n<blockquote>\n<p>“前端的终极归宿是阿里，不是在阿里，就是在去阿里的路上”</p>\n</blockquote>\n<p>另外要说的一点是pc和h5站在使用Node.js做api中间层，其最佳实践已成型，量也是极大的。以前前端玩得还是比较弱，如果能够缓存+控制页面数据，获得一个性能极大的提升也是极好的。2018年，争取拿这个做主题演讲上qcon或archsummit大会。</p>\n<p>每天忙得很开心，这就是我现在状态。其实，我的折腾还是在于想做些事情。如果你也想跟我一起做事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>大公司的做事方式</p>\n<ul>\n<li>按照规矩做事，不要碰红线</li>\n<li>工时一般压的都不会太紧，都是可以商量的，但态度一定要好</li>\n<li>闲的时候自己学点东西，上班要学习相关，下班学不相干的。别犯傻。</li>\n<li>多创造点额外价值，让你的领导更喜欢你</li>\n<li>理解能力要强，不要让你的领导说二遍。</li>\n</ul>\n<p>小公司</p>\n<ul>\n<li>简单粗暴，快速出东西，领导最关心的是进度</li>\n<li>执行力要强，遇佛杀佛，有鬼杀鬼</li>\n<li>代码质量其实没太多人管，但自己要注意养成好习惯</li>\n<li>没有机会自己创造机会。创造机会之前是赢得信任。</li>\n</ul>\n<p>狼叔经常说的一句：“少抱怨，多思考，未来更美好”，大部分人都喜欢积极的人，遇到问题不怕不躲不避，要相信自己能够解决，最多是时间问题。</p>\n<p>还有一句是：“没目标向钱看，有目标向前看”。历史上很多这样的例子，在2010年左右iOS开发刚起步，会拖拽弄个界面的就五位数工资，比做JAVA的几年的都要多。这世界就是这样不公平。但是你也不能不思进取，这样也是极其危险。在2016年左右，其实iOS开发就遇到了市场饱和的问题，很多培训出来的人都找不到工作，各家公司都在考虑换react-native或weex或者h5。</p>\n<p>所以，当你有机会进入一个很有前途的方向，你要努力学好，并准备好下一个阶段的应变。相反，如果当成找一个养老的地方，早晚会遇到尴尬的。比如现在很多iOS程序员被迫去学react/vue等，境遇也不太好的，更有甚者直接被开除。</p>\n<h3>优酷-高级前端开发</h3>\n<p>职位描述</p>\n<ol>\n<li>支撑企业级应用后台开发，使用 React 等前端框架搭建后台页面，实现交互需求及后端服务对接;</li>\n<li>以模块化的思想设计开发通用前端组件，并能够针对OTT,移动端进行针对性优化；</li>\n<li>在理解前端开发流程的基础上，结合前端实际建立或优化提升工作效率的工具；</li>\n<li>在理解产品业务的基础上，提升产品的用户体验，技术驱动业务的发展；</li>\n<li>关注前端前沿技术研究，通过新技术服务团队和业务；</li>\n<li>使用 Weex 技术开发产品需求。&quot;</li>\n</ol>\n<p>职位要求</p>\n<ol>\n<li>精通前端技术，包括HTML/CSS/JavaScript/Node.JS等；</li>\n<li>掌握Bootstrap，jQuery，AngularJS，React等框架，并有项目实践；</li>\n<li>熟悉前端模块化、编译和构建工具，如grunt，gulp,webpack等；</li>\n<li>至少熟悉一门非前端的语言（如Java/PHP/C/C++/Python/Ruby）,有项目实践更佳；</li>\n<li>具备跨终端的前端开发能力，在Web（PC+Mobile）/Node.js/Native App三个方向上至少精通一个方向，具备多个的更佳，鼓励在Native和Web技术融合上的探索；</li>\n<li>具有较强的学习能力，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和产品，UED，后端等方向同学合作。</li>\n</ol>\n<h3>PixelLab</h3>\n<p>PixelLab是与淘宝GM Lab联合成立的专注于视频算法方向的研发部门，主要涉及视频的空间感知、轨迹跟踪、图像分割、遮挡检测以及照片级渲染等相关技术。用于实现视频内的内容植入与后期特效的研发，属于视频MR的场景，主要应用于广告植入平台的研发，方向靠谱老板人好，欢迎推荐。主要需要的岗位包括了图像算法、3D视觉算法，渲染算法，WebGL以及并行计算等几大方向，因为算法类招聘实在难，所以将JD的链接帖出来希望同事们有适合的人可以内推一下。</p>\n<p>岗位要求：</p>\n<ol>\n<li>本科及以上学历，5年以上工作开发经验；</li>\n<li>扎实的计算几何基础，熟悉常见数学工具；</li>\n<li>熟练WebGL, Canvas渲染开发，熟练Shader编写， 熟悉Three.js, OSG.js者优先;</li>\n<li>熟练运用JavaScript语言与HTML5、CSS3等技术;</li>\n<li>熟悉主流移动浏览器的技术特点，有移动端H5, WebGL项目经验者优先;</li>\n<li>有移动端WebGL开发经验者优先;</li>\n<li>学习能力强、应变能力强，优秀的沟通能力和协调能力，执行能力强，具备较强的团队合作精神。</li>\n</ol>\n<h3>蚂蚁金服</h3>\n<p>岗位要求：</p>\n<ul>\n<li>大学本科学历，2年以上开发经验，能熟练使用常见类库或框架，编写高质量的前端代码；</li>\n<li>熟悉NodeJS，有NodeJS开发经验，熟悉Express\\koa等框架；</li>\n<li>熟练掌握React、Redux及相关框架和技术，有单页面应用开发经验；</li>\n<li>精通ES6，gulp，webpack等规范和技术；</li>\n<li>善于 Web 性能优化与前端效果的实现；</li>\n<li>良好的团队合作精神和积极主动的沟通意识，具有很强的学习能力和对新技术的追求精神，乐于分享；</li>\n<li>有大型网站开发经验者优先。</li>\n</ul>\n<p>我们的前端专业建设方向</p>\n<ul>\n<li>基于ReactJS的主题可配置组件化平台</li>\n<li>基于Nodejs的UED中台业务（浏览器端web页面监控等）</li>\n<li>基于Docker的nodejs云容器平台</li>\n<li>基于Webpack的前端工程化体系建设</li>\n<li>基于eggjs的react同构框架</li>\n<li>基于G2的业务数据可视化组件库</li>\n<li>大规模图形识别/图像处理/AR/VR//语音交互等研究性领域探索</li>\n</ul>\n<h3>联系方式</h3>\n<p>目前北京，杭州，广州，上海，深圳，成都都在招聘，如果你也想跟我一起共事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>有机会和winter，勾股，玉伯，苏千，朴灵、死马、偏右，徐飞，阮一峰，天猪，裕波等大神一起工作哦。</p>\n<p>悄悄地说，其实其他公司我也可以帮推荐。</p>\n<h2>结束语</h2>\n<p>年轻时死磕，年长点让小弟死磕，现在抓个专家一起吃饭，没有什么是一顿饭解决不了的，不行就二顿</p>\n<p>工程师的能力不是编码和死磕，而是解决问题</p>\n<ul>\n<li>年轻死磕是为了长本事，30岁以前都可以这样做</li>\n<li>带团队后，要懂得任务下放，让更多人帮你，别带人越多越累</li>\n<li>30岁之后是打牌阶段，技能积累足够用，这时要注重社交，打组合拳才能玩的更好</li>\n</ul>\n<p>强调30岁不是我创造的，大部分人都会认为30岁后事情，压力会明显大得多，比如家庭，孩子，房子，车子，票子，甚至是管理，权利，欲望等等吧。我感受最深的是身体不如从前和记忆力明显下降。</p>\n<p>狼叔说: “少抱怨，多思考，未来更美好”</p>\n<p>大部分人体会不到坚持的乐趣，不会玩，所以抱怨多。其实玩出乐趣也是一种能力，尤其是像写代码这种看似无聊的事儿。最开始可能只想赚点钱，后面变成热爱，这样才美好。只要坚持每日精进开心就好了。</p>\n<p>另外，时间也要好处处理，狼叔总会提菜根谭上的一句话:【闲时要有吃紧的心思，忙里要有偷闲的乐趣】。</p>\n<p>每个人的一生中都有很多坎，类似于瓶颈，唯有苦难和坚持才能冲破，坚持会产生自信，苦难会创造机会。一个经过苦难还有自信的人，一定会有更美好的未来。</p>\n<p>如果大家还有问题，可以去cnode社区发帖at我，也可以在Node全栈公众号提问。</p>\n<h2>Part 5答疑：回答大家的问题</h2>\n<p>答疑有点多，这里就不一一贴出来，如果是新用户和比较迷茫的Node朋友去Live里听吧。</p>\n<ul>\n<li>感谢justjavac大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址</a></li>\n</ul>\n</div>",
        "title": "【全文】狼叔：如何正确的学习Node.js",
        "last_reply_at": "2018-11-16T08:39:32.776Z",
        "good": true,
        "top": false,
        "reply_count": 88,
        "visit_count": 42789,
        "create_at": "2018-03-22T02:35:23.073Z",
        "author": {
            "loginname": "i5ting",
            "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
        }
    },
    {
        "id": "5bee604fbe1b120abac5a04c",
        "author_id": "5ae32aa939a81e4548f457c4",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p>因为读了<a href=\"/user/lizheming\">@lizheming</a> 的帖子<a href=\"https://cnodejs.org/topic/5be8dcf82fed25406c25d805\">API开发中如何使用限速应对大规模访问</a>\n自己也在学习、使用egg开发项目，就参照写了egg-ratelimiter，献给有需要的朋友</p>\n<ul>\n<li>支持egg [js] [ts]</li>\n<li>支持Controller控制器内分别对请求速率进行配置</li>\n</ul>\n<p>详情查看<a href=\"https://github.com/ZQun/egg-ratelimiter\">egg-ratelimiter</a></p>\n</div>",
        "title": "egg.js请求速率限制器egg-ratelimiter",
        "last_reply_at": "2018-11-16T08:33:27.329Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 219,
        "create_at": "2018-11-16T06:14:39.490Z",
        "author": {
            "loginname": "ZQun",
            "avatar_url": "https://avatars2.githubusercontent.com/u/12726554?v=4&s=120"
        }
    },
    {
        "id": "5bee7911a05b0e0ae443be54",
        "author_id": "57d216e13d3520a5387c2b53",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>var Sequelize = require(‘sequelize’);</p>\n<p>var sequelize = require(’./ModelHeader’);</p>\n<p>var PetinfoModel = sequelize.define(‘petinfos’,{\nid:{type:Sequelize.BIGINT,primaryKey:true},\nuid:Sequelize.BIGINT,\nnickname:Sequelize.STRING,\npettype:Sequelize.INTEGER,\npetsort:Sequelize.INTEGER,\nsex:Sequelize.TEXT(‘tiny’),\nage:Sequelize.INTERGER,\nintroduce:Sequelize.STRING,\nupdtime:Sequelize.DATE,\ncreatetime:Sequelize.DATE\n},{\ntimestamps:false,\n});\nmodule.exports = PetinfoModel;</p>\n<p>然后服务端报这个错误</p>\n<p>throw new Error('Unrecognized data type for field ’ + name);\n^\nError: Unrecognized data type for field age</p>\n<p>我在网上查了，可这个错误出现的很少，什么情况</p>\n</div>",
        "title": "用Sequelize做数据库映射的时候，服务端报错  Unrecognized data type for field age",
        "last_reply_at": "2018-11-16T08:19:44.585Z",
        "good": false,
        "top": false,
        "reply_count": 2,
        "visit_count": 160,
        "create_at": "2018-11-16T08:00:17.080Z",
        "author": {
            "loginname": "a69694510",
            "avatar_url": "https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"
        }
    },
    {
        "id": "5bebbc2dbe1b120abac592a2",
        "author_id": "58d83c586f8b9bf02d1d0b1d",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>TCP抓包是否可行</p>\n</div>",
        "title": "微信朋友圈能爬吗",
        "last_reply_at": "2018-11-16T08:16:47.591Z",
        "good": false,
        "top": false,
        "reply_count": 13,
        "visit_count": 796,
        "create_at": "2018-11-14T06:09:49.861Z",
        "author": {
            "loginname": "ResJay",
            "avatar_url": "https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"
        }
    },
    {
        "id": "5ae886c51b02288048bd0b75",
        "author_id": "5ae885ad1b02288048bd0b74",
        "tab": "ask",
        "content": "<div class=\"markdown-text\"><p>小白一个 学了点小基础 希望能够提升一下\n希望各位表哥  分享一下开源项目和学习教程</p>\n</div>",
        "title": "求node和微信小程序的教程或者 开源项目",
        "last_reply_at": "2018-11-16T06:26:23.962Z",
        "good": false,
        "top": false,
        "reply_count": 34,
        "visit_count": 4984,
        "create_at": "2018-05-01T15:24:53.470Z",
        "author": {
            "loginname": "longletian",
            "avatar_url": "https://avatars0.githubusercontent.com/u/28197668?v=4&s=120"
        }
    },
    {
        "id": "5be8dcf82fed25406c25d805",
        "author_id": "597ee3db68aa87c774e5edac",
        "tab": "share",
        "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fo8_CVsdQq6R9DF1Wp34_HkhobF8\" alt=\"稿定设计导出-20181108-204711.png\"></p>\n<p>编者注：俗话说的好 <strong>“并发不够，机器来凑”</strong>，当我们面对高并发请求的时候增加机器是最简单也是最土豪的做法。不过在资源有限的情况除了去优化代码我们又该怎么办呢？今天我们请来了 @有马 同学为我们分享一下他在这方面的经验，希望能帮助到大家。</p>\n<p>———</p>\n<p>想要开发牢固的Web API只考虑安全是不够的，还有一点我们需要考虑，那就是应对大规模访问的对策。不仅是Web API服务，任何在网络上公开的服务都会时不时地遇到来自外部的大规模访问，比如“鹿晗关晓彤公布恋情”这种实时热点。当服务器遇到大规模访问时，为了处理这些访问会耗尽资源，进而无法提供服务。这时不仅是这些大规模访问，任何人都无法和服务器端建立连接。</p>\n<p>我们可以通过程序毫不费力的访问Web API，所以API服务器更容易遇到访问负载高的情况，针对这个问题，和普通的Web应用一样，我们可以对API服务进行扩容，这是正确的做法，但本文不对扩容方案展开讨论。接下来会讨论限速在应对大规模访问时一些重要的点，以及在ThinkJS开发的项目中应该怎样做。</p>\n<h2>限制用户的访问</h2>\n<p>为了解决突然出现大规模访问的问题，最现实的方法是对每个用户的访问次数进行限制。也就是确定单个用户在单位时间里最大的访问次数，如果用户已经超过了最大访问次数，用户再次访问时，服务端将会直接拒绝并返回错误信息。比如设置一个用户10分钟内只允许调用20次获取短信验证码的接口，那么当用户在10分钟内发起第21次请求时，服务器端便会返回错误信息，10分钟之后才会恢复访问。如果进行访问限速，就要先解决下面三个问题：</p>\n<ul>\n<li>如何确定限速的数值</li>\n<li>如何确定限速时间单位</li>\n<li>在什么时候重置限速的数值</li>\n</ul>\n<h3>确定限速数值</h3>\n<p>对数据频繁更新的查询类API而言，用户需要频繁的访问的到最新的数据，如果设置1小时只能访问10次的话，用户肯定不满意，转而去用可以替代的服务。访问限速的初衷是为了应对服务器短时间内遭遇大规模访问不堪重负从而无法提供服务，但如果让用户用起来不方便就得不偿失了，所以要尽可能的了解提供的API在什么情况下被使用，然后决定限速的数值。</p>\n<h3>确定限速时间单位</h3>\n<p>根据在线服务的不同，有些会以一天作为访问次数的时间单位，不过这对很多API来说有点长了，假设使用者正在写脚本访问API，开始并不清楚访问次数的时间单位，那就可能需要让他等24个小时才能继续访问API，或者换一个账号。如果我们以10分钟作为访问次数的时间单位，如果超出访问次数限制，也只需要等10分钟就能继续访问了。虽然单位时间的设定和API返回的数据密切相关，但大部分已公开的API都设置了都设置了1小时左右的单位时间。</p>\n<h3>确定重置限速数值的时间</h3>\n<p>当用户超出访问上限值时，服务端该如何返回响应消息呢？这种情况下可以返回HTTP协议中备好的“429 Too Many Request”状态码。429状态码在2012年4月发布的RFC 6585中定义，当特定用户在一定时间内发起的请求次数过多时，服务器端可以返回该状态码表示出错。RFC 文档中对该状态码描述如下：</p>\n<pre class=\"prettyprint\"><code>429 Too Many Requests\n\n   The 429 status code indicates that the user has sent too many\n   requests in a given amount of time (&quot;rate limiting&quot;).\n\n   The response representations SHOULD include details explaining the\n   condition, and MAY include a Retry-After header indicating how long\n</code></pre><p>通过上面的描述可以知道，响应消息中应该包含错误的详细信息，并且可以通过<code>Retry-After</code>告知用户需要等待多长时间才能访问API。<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\">Retry-After</a>首部表示客户端需要等待多长时间才能再次访问。RFC文档中用 <code>MAY</code> 标记该首部，表示即使不发送该首部也不会有什么问题，只是在响应体加上该首部会显得更加友好。</p>\n<p>另外，<code>Retry-After</code>并不是 429 状态码专用的响应首部。该首部在HTTP 1.1的RFC 7231中定义，它也同样包含在带有503和3xx系列的响应体中。而且<code>Retry-After</code>首部用秒数来指定时间，还可以使用详细的日期信息，可以看一下RFC文档中的描述：</p>\n<pre class=\"prettyprint\"><code>Retry-After\n\n   Servers send the &quot;Retry-After&quot; header field to indicate how long the\n   user agent ought to wait before making a follow-up request.  When\n   sent with a 503 (Service Unavailable) response, Retry-After indicates\n   how long the service is expected to be unavailable to the client.\n   When sent with any 3xx (Redirection) response, Retry-After indicates\n   the minimum time that the user agent is asked to wait before issuing\n   the redirected request.\n\n   The value of this field can be either an HTTP-date or a number of\n   seconds to delay after the response is received.\n\n     Retry-After = HTTP-date &#x2F; delay-seconds\n\n   A delay-seconds value is a non-negative decimal integer, representing\n   time in seconds.\n\n     delay-seconds  = 1*DIGIT\n</code></pre><h2>通过HTTP响应传递限速信息</h2>\n<p>在实施访问限速的过程中，如果能将当前用户访问次数限制、已使用的访问次数以及何时重置访问限速等信息告诉用户，会显得非常友好。如果不返回这些信息的话，用户可能为了确定限速是否解除而多次尝试访问接口API，这样一来无疑又增加了服务器的压力。</p>\n<p>限速信息可以放在响应消息首部，另一种是作为响应消息体数据的一部分，目前将限速信息放在响应消息首部的方式成为事实上的标准。</p>\n<table>\n<thead>\n<tr>\n<th>首部名</th>\n<th>说明</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X-RateLimit-Limit</td>\n<td>单位时间的访问上限</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>X-RateLimit-Remaining</td>\n<td>剩余的访问次数</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>X-RateLimit-Reset</td>\n<td>访问次数重置时间</td>\n<td>UTC epoch seconds</td>\n</tr>\n</tbody>\n</table>\n<p>看一下<a href=\"https://developer.github.com/v3/#rate-limiting\">GitHub的限速策略</a>，GitHub就使用了上面三个响应首部，没有带<code>Retry-After</code>首部。对于认证的请求每小时可以访问5000次，没有认证的请求每小时访问60次。</p>\n<p>而<a href=\"https://developer.twitter.com/en/docs/basics/rate-limiting.html\">Twitter限速策略</a>的时间窗口是15分钟，比GitHub的时间窗口小很多，因为Twitter的数据更新的相对较较快，时间窗口设置小一些才能满足使用者获取最新数据的需求。Twitter使用类似上面三个的响应首部传达限速信息<code>x-rate-limit-limit</code>,<code>x-rate-limit-remaining</code>,<code>x-rate-limit-reset</code>。对于GET请求有两种初始方案，一种是15分钟15次请求，另一种是15分钟180次请求，并且只允许认证访问。</p>\n<p>通过对比GitHub和Twitter的限速策略，可以知道只要准确传达限速信息，响应头部完全可以自己定义，重点是语义明确，且不能和其他标准首部冲突。</p>\n<h2>在ThinkJS中实现API限速控制</h2>\n<p>要实现API访问限速，需要对每个用户及应用访问API的次数进行计数，一般会使用<code>Redis</code>等键值对存储来记录。ThinkJS 结合自己的路由映射方式实现了<a href=\"https://github.com/thinkjs/think-ratelimiter\">think-ratelimiter</a>中间件对<code>action</code>进行限速，你需要在<code>middleware.js</code>里进行如下配置，就可以实现简单的限速策略。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; in middleware.js\nconst redis = require(&#x27;redis&#x27;);\nconst { port, host, password } = think.config(&#x27;redis&#x27;);\nconst db = redis.createClient(port, host, { password });\nconst ratelimiter = require(&#x27;think-ratelimiter&#x27;);\n\nmodule.exports = {\n  &#x2F;&#x2F; after router middleware\n  {\n    handle: ratelimiter,\n    options: {\n      db,\n      errorMessage: &#x27;Sometimes You Just Have To Slow Down&#x27;,\n      headers: {\n        remaining: &#x27;X-RateLimit-Remaining&#x27;,\n        reset: &#x27;X-RateLimit-Reset&#x27;,\n        total: &#x27;X-RateLimit-Limit&#x27;\n      },\n      resources: {\n        &#x27;test&#x2F;test&#x27;: { &#x2F;&#x2F; key 是 controller&#x2F;action 的拼接\n          id: ctx =&gt; ctx.ip,\n          max: 5,\n          duration: 7000 &#x2F;&#x2F; ms\n        }\n      }\n    }\n  },\n}\n</code></pre><p>响应体首部<code>X-RateLimit-Reset</code>表示可以恢复访问的时间，同时也会带着<code>Retry-After</code>首部，它的值是距离恢复时间的秒数。</p>\n<h2>总结</h2>\n<p>在ThinkJS开发的Web应用中，可以使用中间件然后添加配置实现简单的限速，如果你提供的web API服务访问量比较大或者需要付费访问等功能，就需要在真正的逻辑前加一层来做限速相关的事情，在ThinkJS中可以实现一个<code>services/ratelimit.js</code>，然后在项目的<code>base controller</code>中实现限速等逻辑。</p>\n<p><strong>参考资料：</strong></p>\n<ul>\n<li><a href=\"https://book.douban.com/subject/27054104/\">《Web API的设计与开发》</a></li>\n<li><a href=\"https://datatracker.ietf.org/doc/rfc6585/\">RFC 6585</a></li>\n<li><a href=\"https://tools.ietf.org/pdf/rfc7231.pdf\">RFC 7231</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\">Retry-After</a></li>\n</ul>\n</div>",
        "title": "API开发中如何使用限速应对大规模访问",
        "last_reply_at": "2018-11-16T06:07:12.935Z",
        "good": false,
        "top": false,
        "reply_count": 1,
        "visit_count": 409,
        "create_at": "2018-11-12T01:52:56.653Z",
        "author": {
            "loginname": "lizheming",
            "avatar_url": "https://avatars2.githubusercontent.com/u/424491?v=4&s=120"
        }
    }
]
export default {
    data
}